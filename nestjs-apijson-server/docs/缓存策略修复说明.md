# 缓存策略修复说明

## 问题描述

之前的实现在所有请求中都会检查缓存，包括 POST（新增）、PUT（更新）、DELETE（删除）操作。这是不正确的，因为：

1. **查询操作**（GET、HEAD）应该使用缓存以提高性能
2. **修改操作**（POST、PUT、DELETE）不应该使用缓存，因为：
   - 这些操作会修改数据，缓存会失效
   - 修改操作的结果不应该被缓存
   - 每次修改操作都应该执行实际的数据库操作

## 修复方案

### 1. 新增 `isQueryOperation` 方法

在 [`apijson.controller.ts`](../src/controllers/apijson.controller.ts) 中新增方法来判断是否为查询操作：

```typescript
/**
 * 判断是否为查询操作
 * 只有 GET 和 HEAD 方法是查询操作，POST、PUT、DELETE 不是
 */
private isQueryOperation(httpMethod: string, request: APIJSONRequest): boolean {
  const method = httpMethod.toUpperCase();
  
  // 只缓存 GET 和 HEAD 请求
  if (method !== 'GET' && method !== 'HEAD') {
    return false;
  }
  
  // 检查是否有 @method 指令（如果有，则不是纯查询操作）
  const hasMethodDirective = Object.keys(request).some(key => key === '@method');
  if (hasMethodDirective) {
    return false;
  }
  
  return true;
}
```

### 2. 修改 `isCacheableRequest` 方法

简化该方法，只检查是否为数组查询：

```typescript
/**
 * 判断是否为可缓存的请求
 * 只有查询操作且不包含数组查询的请求才可缓存
 */
private isCacheableRequest(request: APIJSONRequest): boolean {
  // 不缓存数组查询
  const hasArrayKey = Object.keys(request).some(key => key.endsWith('[]'));
  return !hasArrayKey;
}
```

### 3. 修改 `handleRequest` 方法

在请求处理流程中，只对查询操作使用缓存：

```typescript
private async handleRequest(
  request: APIJSONRequest,
  httpMethod: string
): Promise<APIJSONResponseDTO> {
  const startTime = Date.now();

  try {
    this.logger.log(`[APIJSON] 开始处理请求: ${httpMethod}, 请求体: ${JSON.stringify(request)}`);

    // 判断是否为查询操作（只对查询操作使用缓存）
    const isQueryOperation = this.isQueryOperation(httpMethod, request);
    this.logger.log(`[APIJSON] 是否为查询操作: ${isQueryOperation}`);

    // 只对查询操作检查和设置缓存
    let cacheKey: string | null = null;
    if (isQueryOperation) {
      cacheKey = this.generateCacheKey(request, httpMethod);
      this.logger.log(`[APIJSON] 缓存键: ${cacheKey}`);

      // 检查缓存
      const cachedResponse = await this.cacheService.get(cacheKey);
      if (cachedResponse) {
        this.logger.log(`[APIJSON] 缓存命中，直接返回缓存数据`);
        return {
          ...cachedResponse,
          cached: true,
          processingTime: Date.now() - startTime,
        };
      }

      this.logger.log(`[APIJSON] 缓存未命中，开始解析请求`);
    }

    // ... 解析、验证、构建、执行 SQL ...

    // 构建响应
    const response: APIJSONResponseDTO = {
      status: 'success',
      code: 200,
      message: '请求成功',
      data: executeResult.data,
      warnings: verifyResult.warnings,
      processingTime: Date.now() - startTime,
      timestamp: new Date().toISOString(),
      path: `/apijson/${httpMethod.toLowerCase()}`,
      cached: false,
    };

    // 只对查询操作缓存响应
    if (isQueryOperation && this.isCacheableRequest(request)) {
      await this.cacheService.set(cacheKey!, response, 300000); // 5分钟
      this.logger.log(`[APIJSON] 响应已缓存`);
    }

    return response;
  } catch (error) {
    // ... 错误处理 ...
  }
}
```

## 修复后的缓存策略

### 使用缓存的操作

以下操作会使用缓存：

1. **GET /apijson/get** - 查询单个对象
2. **POST /apijson/get** - 查询单个对象（推荐）
3. **GET /apijson/gets** - 查询多个对象
4. **POST /apijson/gets** - 查询多个对象（推荐）
5. **POST /apijson/head** - 查询总数
6. **POST /apijson/heads** - 查询多个总数

### 不使用缓存的操作

以下操作不会使用缓存：

1. **POST /apijson/post** - 新增数据
2. **POST /apijson/put** - 更新数据
3. **POST /apijson/delete** - 删除数据
4. **POST /apijson/crud** - 混合操作（包含增删改）
5. 任何包含 `@method` 指令的请求（即使 HTTP 方法是 GET 或 HEAD）
6. 任何数组查询（如 `user[]`）

### 缓存规则

1. **只缓存查询操作** - GET 和 HEAD 方法
2. **不缓存修改操作** - POST、PUT、DELETE 方法
3. **不缓存数组查询** - 包含 `[]` 的表名
4. **不缓存混合操作** - 包含 `@method` 指令的请求
5. **缓存时间** - 5 分钟（300000 毫秒）

## 示例

### 查询操作（使用缓存）

```bash
# 查询单个用户 - 会使用缓存
curl -X 'POST' \
  'http://localhost:3900/api/apijson/get' \
  -H 'Content-Type: application/json' \
  -d '{
  "user": {
    "id": 1
  }
}'

# 第一次请求：缓存未命中，执行数据库查询
# 第二次请求：缓存命中，直接返回缓存数据
```

### 新增操作（不使用缓存）

```bash
# 新增用户 - 不会使用缓存
curl -X 'POST' \
  'http://localhost:3900/api/apijson/post' \
  -H 'Content-Type: application/json' \
  -d '{
  "user": {
    "name": "张三",
    "age": 25
  }
}'

# 每次请求都会执行数据库插入操作
```

### 更新操作（不使用缓存）

```bash
# 更新用户 - 不会使用缓存
curl -X 'POST' \
  'http://localhost:3900/api/apijson/put' \
  -H 'Content-Type: application/json' \
  -d '{
  "user": {
    "id": 1,
    "name": "李四"
  }
}'

# 每次请求都会执行数据库更新操作
```

### 删除操作（不使用缓存）

```bash
# 删除用户 - 不会使用缓存
curl -X 'POST' \
  'http://localhost:3900/api/apijson/delete' \
  -H 'Content-Type: application/json' \
  -d '{
  "user": {
    "id": 1
  }
}'

# 每次请求都会执行数据库删除操作
```

## 日志输出

修复后，日志会明确显示是否为查询操作：

```
[APIJSON] 开始处理请求: POST, 请求体: {"user":{"id":1}}
[APIJSON] 是否为查询操作: true
[APIJSON] 缓存键: apijson:post:eyJ1c2VyIjp7ImlkIjoxfX0=
[APIJSON] 缓存未命中，开始解析请求
...
[APIJSON] 响应已缓存
```

对于修改操作：

```
[APIJSON] 开始处理请求: POST, 请求体: {"user":{"name":"张三","age":25}}
[APIJSON] 是否为查询操作: false
[APIJSON] 缓存未命中，开始解析请求
...
```

## 影响范围

此修复影响以下方面：

1. **性能优化** - 查询操作使用缓存，提高响应速度
2. **数据一致性** - 修改操作不使用缓存，确保数据实时更新
3. **缓存策略** - 明确区分查询和修改操作的缓存行为

## 注意事项

1. 缓存时间设置为 5 分钟，可以根据实际需求调整
2. 数组查询不缓存，因为结果集可能很大
3. 混合操作不缓存，因为可能包含修改操作
4. 如果需要清除缓存，可以调用缓存服务的清除方法

## 相关文件

- [`src/controllers/apijson.controller.ts`](../src/controllers/apijson.controller.ts) - 控制器，包含缓存逻辑
- [`src/modules/cache/cache.service.ts`](../src/modules/cache/cache.service.ts) - 缓存服务
