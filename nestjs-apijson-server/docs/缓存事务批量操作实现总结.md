# 缓存、事务、批量操作实现总结

## 概述

本文档总结了APIJSON ORM系统中缓存机制、事务管理和批量操作的实现情况。

## 一、缓存机制

### 1.1 缓存接口设计

#### 核心接口：ICache

位置：`src/core/cache/cache.interface.ts`

定义了缓存的基本操作接口：

```typescript
interface ICache {
  // 基本操作
  get<T>(key: string): Promise<T | null>;
  set<T>(key: string, value: T, ttl?: number): Promise<void>;
  delete(key: string): Promise<void>;
  clear(): Promise<void>;
  has(key: string): Promise<boolean>;

  // TTL管理
  ttl(key: string): Promise<number>;
  expire(key: string, ttl: number): Promise<void>;

  // 批量操作
  mget<T>(keys: string[]): Promise<Map<string, T>>;
  mset<T>(items: Map<string, T>, ttl?: number): Promise<void>;
  mdelete(keys: string[]): Promise<void>;
}
```

#### 缓存项接口

```typescript
interface CacheItem<T> {
  value: T;           // 缓存值
  expiresAt: number;  // 过期时间戳
  createdAt: number;  // 创建时间戳
}
```

#### 缓存统计信息

```typescript
interface CacheStats {
  hits: number;       // 缓存命中次数
  misses: number;     // 缓存未命中次数
  size: number;       // 缓存项数量
  hitRate: number;    // 缓存命中率
}
```

### 1.2 内存缓存实现

#### 类名：MemoryCacheService

位置：`src/core/cache/memory-cache.service.ts`

**特性：**
- 基于Map的内存存储
- 支持TTL过期自动清理
- 提供缓存统计信息
- 适合单机应用

**核心方法：**

```typescript
@Injectable()
export class MemoryCacheService implements ICache {
  // 获取缓存
  async get<T>(key: string): Promise<T | null>

  // 设置缓存
  async set<T>(key: string, value: T, ttl: number = 3600): Promise<void>

  // 删除缓存
  async delete(key: string): Promise<void>

  // 清空所有缓存
  async clear(): Promise<void>

  // 获取缓存统计
  getStats(): CacheStats

  // 重置统计
  resetStats(): void

  // 获取所有缓存键
  keys(): string[]

  // 获取缓存大小
  size(): number
}
```

**使用示例：**

```typescript
@Injectable()
export class MyService {
  constructor(
    private readonly cache: MemoryCacheService
  ) {}

  async getUser(id: string) {
    // 尝试从缓存获取
    const cached = await this.cache.get<User>(`user:${id}`);
    if (cached) {
      return cached;
    }

    // 从数据库查询
    const user = await this.userRepository.findById(id);

    // 设置缓存，1小时过期
    await this.cache.set(`user:${id}`, user, 3600);

    return user;
  }
}
```

### 1.3 Redis缓存实现

#### 类名：RedisCacheService

位置：`src/core/cache/redis-cache.service.ts`

**特性：**
- 基于Redis的分布式缓存
- 支持多种Redis客户端
- 自动连接管理
- 错误处理和重连
- 适合分布式应用

**Redis客户端接口：**

```typescript
interface IRedisClient {
  get(key: string): Promise<string | null>;
  set(key: string, value: string, mode?: string, duration?: number): Promise<'OK' | null>;
  del(key: string | string[]): Promise<number>;
  exists(key: string): Promise<number>;
  ttl(key: string): Promise<number>;
  expire(key: string, seconds: number): Promise<number>;
  mget(keys: string[]): Promise<(string | null)[]>;
  mset(items: [string, string][]): Promise<'OK' | null>;
  keys(pattern: string): Promise<string[]>;
  dbsize(): Promise<number>;
  flushdb(): Promise<'OK'>;
  on(event: string, listener: (...args: any[]) => void): void;
  connect?(): Promise<void>;
  disconnect?(): Promise<void>;
  quit?(): Promise<void>;
}
```

**核心方法：**

```typescript
@Injectable()
export class RedisCacheService implements ICache, OnModuleInit, OnModuleDestroy {
  constructor(private readonly redisClient: IRedisClient) {}

  // 获取缓存
  async get<T>(key: string): Promise<T | null>

  // 设置缓存
  async set<T>(key: string, value: T, ttl: number = 3600): Promise<void>

  // 获取缓存统计
  async getStats(): Promise<CacheStats>

  // 检查连接状态
  isReady(): boolean
}
```

**使用示例：**

```typescript
// 使用ioredis客户端
import Redis from 'ioredis';

@Module({
  providers: [
    {
      provide: 'REDIS_CLIENT',
      useFactory: () => new Redis({
        host: 'localhost',
        port: 6379,
      }),
    },
    {
      provide: IRedisClient,
      useFactory: (redis: Redis) => new RedisClientAdapter(redis),
      inject: ['REDIS_CLIENT'],
    },
    RedisCacheService,
  ],
})
export class CacheModule {}
```

### 1.4 缓存解析器

#### 类名：CacheParser

位置：`src/core/parsers/cache-parser.ts`

**功能：**
- 解析@cache字段
- 支持多种格式：布尔值、数字、字符串
- 支持时间格式：1h, 30m, 60s

**使用示例：**

```typescript
// 布尔值
{ "@cache": true }  // 启用缓存，默认1小时

// 数字（秒）
{ "@cache": 7200 }  // 启用缓存，2小时

// 字符串
{ "@cache": "true" }  // 启用缓存
{ "@cache": "1h" }    // 1小时
{ "@cache": "30m" }   // 30分钟
{ "@cache": "60s" }   // 60秒
```

## 二、事务管理

### 2.1 事务接口设计

#### 核心接口：ITransaction

位置：`src/core/transaction/transaction.interface.ts`

```typescript
interface ITransaction {
  // 事务控制
  begin(): Promise<void>;
  commit(): Promise<void>;
  rollback(): Promise<void>;

  // 保存点管理
  savepoint(name: string): Promise<void>;
  releaseSavepoint(name: string): Promise<void>;
  rollbackToSavepoint(name: string): Promise<void>;

  // 状态查询
  isInTransaction(): boolean;
  getId(): string;
  getStatus(): TransactionStatus;
  getIsolationLevel(): TransactionIsolationLevel;
  getSavepoints(): string[];
}
```

#### 事务状态枚举

```typescript
enum TransactionStatus {
  NOT_STARTED = 'NOT_STARTED',  // 未开始
  ACTIVE = 'ACTIVE',            // 进行中
  COMMITTED = 'COMMITTED',      // 已提交
  ROLLED_BACK = 'ROLLED_BACK',  // 已回滚
  FAILED = 'FAILED',            // 失败
}
```

#### 事务隔离级别枚举

```typescript
enum TransactionIsolationLevel {
  READ_UNCOMMITTED = 'READ_UNCOMMITTED',  // 读未提交
  READ_COMMITTED = 'READ_COMMITTED',      // 读已提交
  REPEATABLE_READ = 'REPEATABLE_READ',    // 可重复读
  SERIALIZABLE = 'SERIALIZABLE',          // 串行化
}
```

#### 事务配置接口

```typescript
interface TransactionOptions {
  isolationLevel?: TransactionIsolationLevel;  // 隔离级别
  readOnly?: boolean;                          // 是否只读
  timeout?: number;                            // 超时时间（秒）
}
```

### 2.2 事务管理器

#### 类名：TransactionManagerService

位置：`src/core/transaction/transaction-manager.service.ts`

**特性：**
- 管理事务生命周期
- 支持嵌套事务
- 自动提交/回滚
- 事务统计
- 保存点管理

**核心方法：**

```typescript
@Injectable()
export class TransactionManagerService implements ITransactionManager {
  // 开始新事务
  async beginTransaction(options?: TransactionOptions): Promise<ITransaction>

  // 获取当前事务
  getCurrentTransaction(): ITransaction | null

  // 提交当前事务
  async commitCurrentTransaction(): Promise<void>

  // 回滚当前事务
  async rollbackCurrentTransaction(): Promise<void>

  // 在事务中执行操作
  async runInTransaction<T>(
    callback: (transaction: ITransaction) => Promise<T>,
    options?: TransactionOptions,
  ): Promise<T>

  // 检查是否有活动事务
  hasActiveTransaction(): boolean

  // 获取所有活动事务
  getActiveTransactions(): ITransaction[]

  // 获取事务统计
  getStats(): TransactionStats

  // 清理已完成的事务
  cleanup(): void
}
```

**使用示例：**

```typescript
@Injectable()
export class MyService {
  constructor(
    private readonly transactionManager: TransactionManagerService,
    private readonly userRepository: UserRepository,
    private readonly orderRepository: OrderRepository,
  ) {}

  async createUserWithOrder(userData: any, orderData: any) {
    return await this.transactionManager.runInTransaction(async (transaction) => {
      // 创建用户
      const user = await this.userRepository.create(userData);

      // 创建订单（关联用户）
      orderData.userId = user.id;
      const order = await this.orderRepository.create(orderData);

      // 如果所有操作成功，事务会自动提交
      return { user, order };
    });
  }
}
```

### 2.3 保存点管理

**使用示例：**

```typescript
@Injectable()
export class MyService {
  async complexOperation() {
    const transaction = await this.transactionManager.beginTransaction();

    try {
      // 执行第一步操作
      await this.step1();

      // 创建保存点
      await transaction.savepoint('after_step1');

      // 执行第二步操作
      await this.step2();

      // 创建保存点
      await transaction.savepoint('after_step2');

      // 执行第三步操作
      await this.step3();

      // 如果成功，提交事务
      await transaction.commit();
    } catch (error) {
      // 如果第二步失败，回滚到第一步之后
      if (error.step === 2) {
        await transaction.rollbackToSavepoint('after_step1');
        // 尝试其他操作...
      } else {
        // 完全回滚
        await transaction.rollback();
      }
    }
  }
}
```

## 三、批量操作

### 3.1 批量操作接口设计

#### 核心接口：IBatchOperation

位置：`src/core/batch/batch-operation.interface.ts`

```typescript
interface IBatchOperation {
  // 批量插入
  batchInsert<T>(table: string, data: T[]): Promise<BatchResult<T>>

  // 批量更新
  batchUpdate<T>(table: string, data: T[]): Promise<BatchResult<T>>

  // 批量删除
  batchDelete(table: string, ids: (string | number)[]): Promise<BatchResult>

  // 批量执行SQL
  batchExecute(sqls: string[]): Promise<BatchExecuteResult>

  // 批量查询
  batchQuery<T>(queries: BatchQueryConfig[]): Promise<T[]>
}
```

#### 批量操作结果接口

```typescript
interface BatchResult<T = any> {
  successCount: number;           // 成功数量
  failureCount: number;          // 失败数量
  totalCount: number;             // 总数量
  successData?: T[];             // 成功的数据
  failures?: BatchFailure<T>[];    // 失败的数据及错误信息
  generatedIds?: (string | number)[];  // 生成的ID列表
  affectedRows?: number;          // 影响的行数
}
```

#### 批量操作选项

```typescript
interface BatchOptions {
  batchSize?: number;            // 批量大小，默认100
  parallel?: boolean;            // 是否并行执行，默认false
  concurrency?: number;          // 并行数，默认5
  continueOnError?: boolean;     // 遇到错误是否继续，默认true
  useTransaction?: boolean;      // 是否使用事务，默认false
  retryCount?: number;           // 重试次数，默认0
  retryDelay?: number;           // 重试延迟（毫秒），默认1000
  onProgress?: BatchProgressCallback;  // 进度回调
}
```

### 3.2 批量操作服务

#### 类名：BatchOperationService

位置：`src/core/batch/batch-operation.service.ts`

**特性：**
- 支持批量插入、更新、删除
- 支持批量执行SQL
- 支持批量查询
- 支持分批处理
- 支持并行执行
- 支持事务
- 支持重试机制
- 支持进度报告
- 详细的错误信息

**核心方法：**

```typescript
@Injectable()
export class BatchOperationService implements IBatchOperation {
  // 批量插入
  async batchInsert<T>(
    table: string,
    data: T[],
    options?: BatchOptions,
  ): Promise<BatchResult<T>>

  // 批量更新
  async batchUpdate<T>(
    table: string,
    data: T[],
    options?: BatchOptions,
  ): Promise<BatchResult<T>>

  // 批量删除
  async batchDelete(
    table: string,
    ids: (string | number)[],
    options?: BatchOptions,
  ): Promise<BatchResult>

  // 批量执行SQL
  async batchExecute(
    sqls: string[],
    options?: BatchOptions,
  ): Promise<BatchExecuteResult>

  // 批量查询
  async batchQuery<T>(
    queries: BatchQueryConfig[],
    options?: BatchOptions,
  ): Promise<T[]>
}
```

### 3.3 使用示例

#### 批量插入

```typescript
@Injectable()
export class MyService {
  constructor(
    private readonly batchOperation: BatchOperationService,
  ) {}

  async importUsers(users: any[]) {
    const result = await this.batchOperation.batchInsert(
      'User',
      users,
      {
        batchSize: 100,           // 每批100条
        useTransaction: true,     // 使用事务
        continueOnError: true,    // 遇到错误继续
        onProgress: (progress) => {
          console.log(`进度: ${progress.percentage}%`);
        },
      }
    );

    console.log(`成功: ${result.successCount}, 失败: ${result.failureCount}`);
    console.log(`生成的ID: ${result.generatedIds}`);

    return result;
  }
}
```

#### 批量更新

```typescript
async updateUsers(users: any[]) {
  const result = await this.batchOperation.batchUpdate(
    'User',
    users,  // 每项必须包含id或id{}
    {
      batchSize: 50,
      retryCount: 3,      // 失败重试3次
      retryDelay: 1000,   // 重试延迟1秒
    }
  );

  return result;
}
```

#### 批量删除

```typescript
async deleteUsers(ids: number[]) {
  const result = await this.batchOperation.batchDelete(
    'User',
    ids,
    {
      batchSize: 100,
      useTransaction: true,
    }
  );

  return result;
}
```

#### 批量执行SQL

```typescript
async executeScripts(sqls: string[]) {
  const result = await this.batchOperation.batchExecute(
    sqls,
    {
      batchSize: 10,
      continueOnError: false,  // 遇到错误停止
    }
  );

  return result;
}
```

#### 批量查询

```typescript
async batchGetUsers(userIds: number[]) {
  const queries = userIds.map(id => ({
    sql: 'SELECT * FROM User WHERE id = ?',
    params: [id],
  }));

  const results = await this.batchOperation.batchQuery<User>(
    queries,
    {
      batchSize: 50,
      parallel: true,      // 并行执行
      concurrency: 10,      // 并行数10
    }
  );

  return results;
}
```

## 四、模块导出

### 4.1 缓存模块

```typescript
// src/core/cache/index.ts
export * from './cache.interface';
export * from './memory-cache.service';
export * from './redis-cache.service';
```

### 4.2 事务模块

```typescript
// src/core/transaction/index.ts
export * from './transaction.interface';
export * from './transaction-manager.service';
```

### 4.3 批量操作模块

```typescript
// src/core/batch/index.ts
export * from './batch-operation.interface';
export * from './batch-operation.service';
```

## 五、最佳实践

### 5.1 缓存使用建议

1. **合理设置TTL**：根据数据更新频率设置合适的过期时间
2. **使用批量操作**：使用mget/mset提高性能
3. **监控缓存命中率**：定期检查缓存统计信息
4. **缓存键设计**：使用有意义的命名规范，如`user:${id}`, `list:${type}:${page}`
5. **缓存穿透防护**：对不存在的数据也缓存空值

### 5.2 事务使用建议

1. **保持事务简短**：事务时间越长，锁竞争越严重
2. **合理设置隔离级别**：根据业务需求选择合适的隔离级别
3. **使用保存点**：在复杂操作中使用保存点实现部分回滚
4. **错误处理**：确保事务在异常时正确回滚
5. **避免嵌套事务**：嵌套事务会增加复杂性

### 5.3 批量操作使用建议

1. **合理设置批量大小**：通常100-1000之间
2. **使用事务**：批量写操作建议使用事务
3. **并行查询**：批量查询可以使用并行提高性能
4. **错误处理**：设置continueOnError决定遇到错误是否继续
5. **进度报告**：对长时间操作使用进度回调

## 六、性能优化

### 6.1 缓存优化

- 使用Redis替代内存缓存实现分布式缓存
- 使用mget/mset减少网络往返
- 合理设置TTL避免内存占用过大
- 使用缓存预热提高命中率

### 6.2 事务优化

- 减少事务持有时间
- 使用适当的隔离级别
- 避免长事务
- 使用连接池

### 6.3 批量操作优化

- 使用批量SQL语句
- 合理设置批量大小
- 使用并行执行
- 使用预处理语句

## 七、总结

本次实现完成了以下功能：

1. **缓存机制**
   - ✅ 缓存接口设计
   - ✅ 内存缓存实现
   - ✅ Redis缓存实现
   - ✅ 缓存解析器

2. **事务管理**
   - ✅ 事务接口设计
   - ✅ 事务管理器实现
   - ✅ 保存点管理
   - ✅ 事务统计

3. **批量操作**
   - ✅ 批量操作接口设计
   - ✅ 批量插入
   - ✅ 批量更新
   - ✅ 批量删除
   - ✅ 批量执行SQL
   - ✅ 批量查询

这些功能的实现为APIJSON ORM系统提供了完整的缓存、事务和批量操作支持，可以满足各种复杂业务场景的需求。
