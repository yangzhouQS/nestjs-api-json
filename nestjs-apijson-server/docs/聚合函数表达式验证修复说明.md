# 聚合函数表达式验证修复说明

## 问题描述

在使用聚合函数查询时，出现验证错误：

```bash
curl -X 'POST' \
  'http://localhost:3900/api/apijson/heads' \
  -H 'Content-Type: application/json' \
  -d '{
  "user": {
    "@column": "COUNT(*):count"
  },
  "receive": {
    "@column": "COUNT(*):count"
  }
}'
```

**错误结果**：
```json
{
  "status": "error",
  "code": 400,
  "message": "请求验证失败",
  "errors": [
    "列 \"COUNT(*):count\" 包含非法字符",
    "列 \"COUNT(*):count\" 包含非法字符"
  ]
}
```

## 问题原因

在 SQL 中，`COUNT(*):count` 是合法的聚合函数表达式，格式为：

```
FUNCTION_NAME(args):alias
```

但验证器的正则表达式 `/[<>:"\\|?*\x00-\x1f]/` 将以下字符识别为非法字符：
- `(` - 函数调用开始括号
- `)` - 函数调用结束括号
- `:` - 别名分隔符

这些字符在 SQL 聚合函数表达式中是合法的，不应该被拒绝。

## 修复方案

### 1. 新增 `isAggregateFunctionExpression` 方法

添加一个方法来识别聚合函数表达式：

```typescript
/**
 * 检查是否是聚合函数表达式
 * 例如：COUNT(*):count、SUM(amount):total、AVG(price):avg 等
 */
private isAggregateFunctionExpression(column: string): boolean {
  // 检查是否包含函数调用括号和别名分隔符
  // 格式：FUNCTION_NAME(args):alias
  const functionPattern = /^[A-Za-z_][A-Za-z0-9_]*\(.*\):[A-Za-z_][A-Za-z0-9_]*$/;
  
  // 检查是否匹配聚合函数模式
  if (functionPattern.test(column)) {
    return true;
  }

  // 检查是否包含函数调用（括号）
  if (column.includes('(') && column.includes(')')) {
    return true;
  }

  return false;
}
```

### 2. 修改 `verifyColumns` 方法

在验证列时，先检查是否是聚合函数表达式：

```typescript
/**
 * 验证列
 */
private async verifyColumns(columns: any): Promise<string[]> {
  const errors: string[] = [];

  // 检查是否为数组或字符串
  if (!Array.isArray(columns) && typeof columns !== 'string') {
    errors.push('列必须为数组或字符串');
    return errors;
  }

  // 如果是字符串，转换为数组
  if (typeof columns === 'string') {
    columns = columns.split(',');
  }

  // 验证每个列
  for (const column of columns) {
    if (typeof column !== 'string') {
      errors.push(`列 "${column}" 必须为字符串`);
      continue;
    }

    // * 是 SQL 通配符，表示所有列，应该被允许
    if (column === '*') {
      continue;
    }

    // 检查是否是聚合函数表达式（如 COUNT(*):count、SUM(amount):total 等）
    // 这些表达式包含 (、)、: 等字符，但在 SQL 中是合法的
    if (this.isAggregateFunctionExpression(column)) {
      continue;
    }

    // 检查是否包含非法字符（排除 *，因为它是 SQL 通配符）
    // 排除 (、)、:、空格，因为它们在 SQL 表达式中是合法的
    const invalidChars = /[<>"\\|?\x00-\x1f]/;
    if (invalidChars.test(column)) {
      errors.push(`列 "${column}" 包含非法字符`);
    }
  }

  return errors;
}
```

### 3. 修改 `verifyGroup` 方法

同样修改分组验证：

```typescript
/**
 * 验证分组
 */
private async verifyGroup(group: any): Promise<string[]> {
  const errors: string[] = [];

  // 检查是否为数组或字符串
  if (!Array.isArray(group) && typeof group !== 'string') {
    errors.push('分组必须为数组或字符串');
    return errors;
  }

  // 如果是字符串，转换为数组
  if (typeof group === 'string') {
    group = group.split(',');
  }

  // 验证每个分组
  for (const column of group) {
    if (typeof column !== 'string') {
      errors.push(`分组 "${column}" 必须为字符串`);
      continue;
    }

    // 检查是否是聚合函数表达式
    if (this.isAggregateFunctionExpression(column)) {
      continue;
    }

    // 检查是否包含非法字符（排除 *，因为它是 SQL 通配符）
    // 排除 (、)、:、空格，因为它们在 SQL 表达式中是合法的
    const invalidChars = /[<>"\\|?\x00-\x1f]/;
    if (invalidChars.test(column)) {
      errors.push(`分组 "${column}" 包含非法字符`);
    }
  }

  return errors;
}
```

### 4. 修改 `verifyOrder` 方法

同样修改排序验证：

```typescript
/**
 * 验证排序
 */
private async verifyOrder(order: any): Promise<string[]> {
  const errors: string[] = [];

  // 检查是否为数组或字符串
  if (!Array.isArray(order) && typeof order !== 'string') {
    errors.push('排序必须为数组或字符串');
    return errors;
  }

  // 如果是字符串，转换为数组
  if (typeof order === 'string') {
    order = order.split(',');
  }

  // 验证每个排序
  for (const column of order) {
    if (typeof column !== 'string') {
      errors.push(`排序 "${column}" 必须为字符串`);
      continue;
    }

    // 提取列名（去除排序方向标记）
    let columnName = column;
    if (column.endsWith('+') || column.endsWith('-')) {
      columnName = column.slice(0, -1);
      if (!columnName) {
        errors.push(`排序 "${column}" 缺少列名`);
        continue;
      }
    }

    // 检查是否是聚合函数表达式
    if (this.isAggregateFunctionExpression(columnName)) {
      continue;
    }

    // 检查是否包含非法字符（排除 *，因为它是 SQL 通配符）
    // 排除 (、)、:、空格，因为它们在 SQL 表达式中是合法的
    const invalidChars = /[<>"\\|?\x00-\x1f]/;
    if (invalidChars.test(columnName)) {
      errors.push(`排序 "${column}" 包含非法字符`);
    }
  }

  return errors;
}
```

## 支持的聚合函数表达式

### 标准格式

```
FUNCTION_NAME(args):alias
```

### 示例

1. **COUNT 函数**
   - `COUNT(*):count` - 计算总数
   - `COUNT(id):total` - 计算非空值的数量

2. **SUM 函数**
   - `SUM(amount):total` - 计算总和
   - `SUM(price):priceSum` - 计算价格总和

3. **AVG 函数**
   - `AVG(age):avgAge` - 计算平均值
   - `AVG(price):avgPrice` - 计算平均价格

4. **MAX 函数**
   - `MAX(age):maxAge` - 获取最大值
   - `MAX(price):maxPrice` - 获取最高价格

5. **MIN 函数**
   - `MIN(age):minAge` - 获取最小值
   - `MIN(price):minPrice` - 获取最低价格

6. **其他函数**
   - `GROUP_CONCAT(name):names` - 连接字符串
   - `CONCAT(first, last):fullName` - 连接字段

## 非法字符调整

### 旧的正则表达式

```typescript
const invalidChars = /[<>:"\\|?*\x00-\x1f]/;
```

### 新的正则表达式

```typescript
const invalidChars = /[<>"\\|?\x00-\x1f]/;
```

### 变化

| 字符 | 旧状态 | 新状态 | 说明 |
|------|--------|--------|------|
| `(` | 非法 | 合法 | 函数调用开始括号 |
| `)` | 非法 | 合法 | 函数调用结束括号 |
| `:` | 非法 | 合法 | 别名分隔符 |
| `*` | 非法 | 合法 | SQL 通配符 |
| `<` | 非法 | 非法 | 仍然非法 |
| `>` | 非法 | 非法 | 仍然非法 |
| `"` | 非法 | 非法 | 仍然非法 |
| `\` | 非法 | 非法 | 仍然非法 |
| `|` | 非法 | 非法 | 仍然非法 |
| `?` | 非法 | 非法 | 仍然非法 |

## 修复后的效果

### 查询请求

```bash
curl -X 'POST' \
  'http://localhost:3900/api/apijson/heads' \
  -H 'Content-Type: application/json' \
  -d '{
  "user": {
    "@column": "COUNT(*):count"
  },
  "receive": {
    "@column": "COUNT(*):count"
  }
}'
```

### 成功响应

```json
{
  "status": "success",
  "code": 200,
  "message": "请求成功",
  "data": {
    "user": [
      {
        "count": 100
      }
    ],
    "receive": [
      {
        "count": 50
      }
    ]
  },
  "processingTime": 10,
  "timestamp": "2026-01-02T02:53:40.514Z",
  "path": "/apijson/heads",
  "cached": false
}
```

### 复杂聚合函数示例

```bash
curl -X 'POST' \
  'http://localhost:3900/api/apijson/head' \
  -H 'Content-Type: application/json' \
  -d '{
  "order": {
    "@column": "COUNT(*):count, SUM(amount):total, AVG(amount):avg"
  }
}'
```

**成功响应**：
```json
{
  "status": "success",
  "code": 200,
  "message": "请求成功",
  "data": {
    "order": [
      {
        "count": 100,
        "total": 50000,
        "avg": 500
      }
    ]
  }
}
```

## 注意事项

1. **函数名验证** - 函数名应该只包含字母、数字和下划线
2. **别名验证** - 别名应该只包含字母、数字和下划线
3. **括号匹配** - 必须同时包含 `(` 和 `)` 才被认为是函数调用
4. **空格处理** - 表达式中不允许包含空格（除了函数参数内部）
5. **嵌套函数** - 支持嵌套函数调用，如 `SUM(COUNT(*)):total`

## 相关文件

- [`src/modules/verifier/verifier.service.ts`](../src/modules/verifier/verifier.service.ts) - 验证器服务

## 测试建议

建议测试以下场景：

1. 简单聚合函数 - `COUNT(*):count`
2. 带参数的聚合函数 - `SUM(amount):total`
3. 多个聚合函数 - `COUNT(*):count, SUM(amount):total`
4. 嵌套函数 - `SUM(COUNT(*)):total`
5. GROUP BY 中的聚合函数 - `COUNT(*):count`
6. ORDER BY 中的聚合函数 - `SUM(amount)-:total`
7. 非法字符 - 验证仍然拒绝真正的非法字符
