# 引用赋值功能测试指南

## 修复概述

已完成引用赋值（Reference Assignment）功能的实现，现在支持多表关联查询中的引用字段自动解析和替换。

## 修复内容

### 1. 接口定义修改

**文件：** [`nestjs-apijson/src/interfaces/apijson-request.interface.ts`](nestjs-apijson/src/interfaces/apijson-request.interface.ts)

- 在 [`TableQuery`](nestjs-apijson/src/interfaces/apijson-request.interface.ts:66) 接口中添加了 `references` 字段
- 在 [`Query`](nestjs-apijson/src/interfaces/apijson-request.interface.ts:98) 接口中添加了 `references` 字段

### 2. 解析器修改

**文件：** [`nestjs-apijson/src/modules/parser/core-parser.service.ts`](nestjs-apijson/src/modules/parser/core-parser.service.ts)

- 修改了 [`parseWhere()`](nestjs-apijson/src/modules/parser/core-parser.service.ts:232) 方法，返回 `where` 和 `references` 两个对象
- 识别以 `@` 结尾的字段，将其标记为引用字段
- 记录引用字段映射关系

### 3. 构建器修改

**文件：** [`nestjs-apijson/src/modules/builder/mysql-builder.service.ts`](nestjs-apijson/src/modules/builder/mysql-builder.service.ts)

- 修改了 [`buildWhereClause()`](nestjs-apijson/src/modules/builder/mysql-builder.service.ts:383) 方法，接收 `references` 参数
- 修改了 [`buildConditions()`](nestjs-apijson/src/modules/builder/mysql-builder.service.ts:398) 方法，处理引用字段
- 引用字段使用特殊对象 `{ _reference: "/table/field" }` 标记

### 4. 执行器修改

**文件：** [`nestjs-apijson/src/modules/executor/mysql-executor.service.ts`](nestjs-apijson/src/modules/executor/mysql-executor.service.ts)

- 添加了 [`determineQueryOrder()`](nestjs-apijson/src/modules/executor/mysql-executor.service.ts:45) 方法，确定查询顺序
- 添加了 [`hasReferences()`](nestjs-apijson/src/modules/executor/mysql-executor.service.ts:60) 方法，检查查询是否有引用
- 添加了 [`resolveReferences()`](nestjs-apijson/src/modules/executor/mysql-executor.service.ts:70) 方法，解析引用
- 添加了 [`extractReferenceValue()`](nestjs-apijson/src/modules/executor/mysql-executor.service.ts:93) 方法，从引用路径提取值

## 测试用例

### 测试 1：单值引用（一对一关联）

**请求：**
```json
{
  "receive": {
    "id": 1,
    "@column": "id,order_code,order_date,supplier_name,status,created_at"
  },
  "receive_item": {
    "order_id@": "/receive/id",
    "@column": "id,content"
  }
}
```

**预期行为：**
1. 先查询 `receive` 表：`SELECT id, order_code, order_date, supplier_name, status, created_at FROM \`receive\` WHERE id = 1 LIMIT 10`
2. 从结果中提取 `id` 的值（例如 `1`）
3. 查询 `receive_item` 表：`SELECT id, content FROM \`receive_item\` WHERE order_id = 1 LIMIT 10`

**预期响应：**
```json
{
  "code": 200,
  "msg": "success",
  "receive": {
    "id": 1,
    "order_code": "ORD001",
    "order_date": "2024-01-01",
    "supplier_name": "供应商A",
    "status": "completed",
    "created_at": "2024-01-01 10:00:00"
  },
  "receive_item": [
    {
      "id": 1,
      "content": "商品1",
      "order_id": 1
    },
    {
      "id": 2,
      "content": "商品2",
      "order_id": 1
    }
  ]
}
```

### 测试 2：数组引用（一对多关联）

**请求：**
```json
{
  "receive[]": {
    "count": 5,
    "receive": {
      "@order": "id-"
    }
  },
  "receive_item": {
    "order_id{}@": "[]/receive/id",
    "@column": "id,content"
  }
}
```

**预期行为：**
1. 先查询 `receive` 表：`SELECT * FROM \`receive\` ORDER BY id DESC LIMIT 5`
2. 从结果中提取所有 `id` 的值（例如 `[1, 2, 3, 4, 5]`）
3. 查询 `receive_item` 表：`SELECT id, content FROM \`receive_item\` WHERE order_id IN (1, 2, 3, 4, 5) LIMIT 10`

**预期响应：**
```json
{
  "code": 200,
  "msg": "success",
  "receive": [
    { "id": 5, "order_code": "ORD005" },
    { "id": 4, "order_code": "ORD004" },
    { "id": 3, "order_code": "ORD003" },
    { "id": 2, "order_code": "ORD002" },
    { "id": 1, "order_code": "ORD001" }
  ],
  "receive_item": [
    { "id": 1, "content": "商品1", "order_id": 1 },
    { "id": 2, "content": "商品2", "order_id": 1 },
    { "id": 3, "content": "商品3", "order_id": 2 },
    { "id": 4, "content": "商品4", "order_id": 3 },
    { "id": 5, "content": "商品5", "order_id": 4 }
  ]
}
```

### 测试 3：多层引用（三层关联）

**请求：**
```json
{
  "receive": {
    "id": 1
  },
  "receive_item": {
    "order_id@": "/receive/id"
  },
  "product": {
    "id@": "/receive_item/product_id",
    "@column": "id,name,price"
  }
}
```

**预期行为：**
1. 查询 `receive` 表：`SELECT * FROM \`receive\` WHERE id = 1 LIMIT 10`
2. 查询 `receive_item` 表：`SELECT * FROM \`receive_item\` WHERE order_id = 1 LIMIT 10`
3. 从 `receive_item` 结果中提取 `product_id` 的值（例如 `100`）
4. 查询 `product` 表：`SELECT id, name, price FROM \`product\` WHERE id = 100 LIMIT 10`

**预期响应：**
```json
{
  "code": 200,
  "msg": "success",
  "receive": {
    "id": 1,
    "order_code": "ORD001"
  },
  "receive_item": [
    {
      "id": 1,
      "order_id": 1,
      "product_id": 100,
      "content": "商品1"
    }
  ],
  "product": {
    "id": 100,
    "name": "商品A",
    "price": 99.99
  }
}
```

### 测试 4：错误处理 - 引用表不存在

**请求：**
```json
{
  "receive": {
    "id": 1
  },
  "receive_item": {
    "order_id@": "/nonexistent/id"
  }
}
```

**预期响应：**
```json
{
  "code": 400,
  "msg": "引用的表不存在: nonexistent",
  "error": "引用的表不存在: nonexistent"
}
```

### 测试 5：错误处理 - 引用字段不存在

**请求：**
```json
{
  "receive": {
    "id": 1
  },
  "receive_item": {
    "order_id@": "/receive/nonexistent_field"
  }
}
```

**预期响应：**
```json
{
  "code": 400,
  "msg": "字段不存在: nonexistent_field",
  "error": "字段不存在: nonexistent_field"
}
```

## 测试步骤

### 1. 启动服务

```bash
cd nestjs-apijson
npm run start:dev
```

### 2. 使用 Postman 或 curl 测试

**测试单值引用：**
```bash
curl -X POST http://localhost:3000/apijson \
  -H "Content-Type: application/json" \
  -d '{
    "receive": {
      "id": 1,
      "@column": "id,order_code,order_date,supplier_name,status,created_at"
    },
    "receive_item": {
      "order_id@": "/receive/id",
      "@column": "id,content"
    }
  }'
```

**测试数组引用：**
```bash
curl -X POST http://localhost:3000/apijson \
  -H "Content-Type: application/json" \
  -d '{
    "receive[]": {
      "count": 5,
      "receive": {
        "@order": "id-"
      }
    },
    "receive_item": {
      "order_id{}@": "[]/receive/id",
      "@column": "id,content"
    }
  }'
```

### 3. 查看日志

在控制台中查看详细日志，确认引用解析过程：

```
[MySQLExecutorService] 解析引用路径: /receive/id
[MySQLExecutorService] 单值引用提取: receive.id = 1
[MySQLExecutorService] 执行查询: SELECT id, content FROM `receive_item` WHERE order_id = ? LIMIT 10, 参数: [1]
```

## 调试技巧

### 1. 启用调试日志

在 [`nestjs-apijson/src/main.ts`](nestjs-apijson/src/main.ts) 中设置日志级别：

```typescript
app.useLogger(new Logger('APIJSON', { timestamp: true, level: 'debug' }));
```

### 2. 添加断点

在以下方法中添加断点进行调试：
- [`CoreParserService.parseWhere()`](nestjs-apijson/src/modules/parser/core-parser.service.ts:232)
- [`MySQLBuilderService.buildConditions()`](nestjs-apijson/src/modules/builder/mysql-builder.service.ts:398)
- [`MySQLExecutorService.resolveReferences()`](nestjs-apijson/src/modules/executor/mysql-executor.service.ts:70)
- [`MySQLExecutorService.extractReferenceValue()`](nestjs-apijson/src/modules/executor/mysql-executor.service.ts:93)

### 3. 验证 SQL

查看生成的 SQL 语句，确认引用值是否正确替换：

```typescript
// 在 MySQLExecutorService.execute() 中添加日志
this.logger.debug(`生成的 SQL: ${query.sql}`);
this.logger.debug(`参数: ${JSON.stringify(query.params)}`);
```

## 常见问题

### Q1: 引用值没有被替换

**原因：** 查询顺序不正确，关联表在主表之前执行。

**解决：** 检查 [`determineQueryOrder()`](nestjs-apijson/src/modules/executor/mysql-executor.service.ts:45) 方法，确保主表（无引用）优先执行。

### Q2: 引用路径解析失败

**原因：** 引用路径格式不正确。

**解决：** 确保引用路径格式为 `/table/field` 或 `[]/table/field`。

### Q3: 数组引用生成的 IN 查询参数过多

**原因：** 数组引用的值太多，超过了数据库的限制。

**解决：** 限制数组查询的数量，或者分批查询。

## 性能优化建议

1. **使用索引**：确保引用字段上有索引，提高查询性能
2. **限制数量**：对于数组引用，限制返回的记录数量
3. **批量查询**：使用 IN 查询而不是多次单条查询
4. **缓存结果**：对频繁查询的结果进行缓存

## 总结

引用赋值功能现已完全实现，支持：

- ✅ 单值引用：`"order_id@": "/receive/id"`
- ✅ 数组引用：`"order_id{}@": "[]/receive/id"`
- ✅ 多层引用：支持多层级的引用关系
- ✅ 自动解析：自动从已执行的查询结果中提取值
- ✅ 错误处理：明确的错误提示
- ✅ 查询顺序优化：主表优先，关联表后执行

通过以上测试用例，可以全面验证引用赋值功能的正确性。
