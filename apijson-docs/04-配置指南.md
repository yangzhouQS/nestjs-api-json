# APIJSONORM 配置指南

## 1. 概述

APIJSONORM 提供了丰富的配置选项，可以根据项目需求进行灵活配置。本文档详细介绍各种配置项及其使用方法。

## 2. 基础配置

### 2.1 Maven 依赖

在项目的 `pom.xml` 中添加 APIJSONORM 依赖：

```xml
<dependency>
    <groupId>com.github.Tencent</groupId>
    <artifactId>APIJSON</artifactId>
    <version>8.1.0</version>
</dependency>
```

### 2.2 Gradle 依赖

在项目的 `build.gradle` 中添加 APIJSONORM 依赖：

```gradle
dependencies {
    implementation 'com.github.Tencent:APIJSON:8.1.0'
}
```

## 3. 核心配置类

### 3.1 AbstractParser 配置

#### 3.1.1 分页配置

```java
// 分页页码是否从 1 开始，默认为从 0 开始
public static boolean IS_START_FROM_1 = false;

// 最大查询页码
public static int MAX_QUERY_PAGE = 100;

// 默认查询数量
public static int DEFAULT_QUERY_COUNT = 10;

// 最大查询数量
public static int MAX_QUERY_COUNT = 100;

// 最大更新数量
public static int MAX_UPDATE_COUNT = 10;
```

**示例**：

```java
// 设置分页从 1 开始
AbstractParser.IS_START_FROM_1 = true;

// 设置最大查询页码为 200
AbstractParser.MAX_QUERY_PAGE = 200;

// 设置默认查询数量为 20
AbstractParser.DEFAULT_QUERY_COUNT = 20;
```

#### 3.1.2 查询限制配置

```java
// 最大 SQL 执行数量
public static int MAX_SQL_COUNT = 200;

// 最大对象数量
public static int MAX_OBJECT_COUNT = 5;

// 最大数组数量
public static int MAX_ARRAY_COUNT = 5;

// 最大查询深度
public static int MAX_QUERY_DEPTH = 5;
```

**示例**：

```java
// 设置最大 SQL 执行数量为 500
AbstractParser.MAX_SQL_COUNT = 500;

// 设置最大查询深度为 10
AbstractParser.MAX_QUERY_DEPTH = 10;
```

#### 3.1.3 日志配置

```java
// 打印请求字符串日志
public static boolean IS_PRINT_REQUEST_STRING_LOG = false;

// 打印大数据量日志
public static boolean IS_PRINT_BIG_LOG = false;

// 打印请求结束时间日志
public static boolean IS_PRINT_REQUEST_ENDTIME_LOG = false;

// 返回堆栈跟踪
public static boolean IS_RETURN_STACK_TRACE = true;
```

**示例**：

```java
// 启用请求字符串日志
AbstractParser.IS_PRINT_REQUEST_STRING_LOG = true;

// 启用大数据量日志
AbstractParser.IS_PRINT_BIG_LOG = true;

// 启用请求结束时间日志
AbstractParser.IS_PRINT_REQUEST_ENDTIME_LOG = true;
```

### 3.2 AbstractVerifier 配置

#### 3.2.1 验证配置

```java
// 启用角色验证
public static boolean ENABLE_VERIFY_ROLE = true;

// 启用内容验证
public static boolean ENABLE_VERIFY_CONTENT = true;
```

**示例**：

```java
// 禁用角色验证
AbstractVerifier.ENABLE_VERIFY_ROLE = false;

// 禁用内容验证
AbstractVerifier.ENABLE_VERIFY_CONTENT = false;
```

### 3.3 AbstractFunctionParser 配置

#### 3.3.1 函数配置

```java
// 启用远程函数
public static boolean ENABLE_REMOTE_FUNCTION = true;

// 启用脚本函数
public static boolean ENABLE_SCRIPT_FUNCTION = true;
```

**示例**：

```java
// 禁用远程函数
AbstractFunctionParser.ENABLE_REMOTE_FUNCTION = false;

// 禁用脚本函数
AbstractFunctionParser.ENABLE_SCRIPT_FUNCTION = false;
```

### 3.4 AbstractSQLConfig 配置

#### 3.4.1 数据库配置

```java
// 默认数据库
public static String DEFAULT_DATABASE = "sys";

// 默认模式
public static String DEFAULT_SCHEMA = "public";

// 默认数据源
public static String DEFAULT_DATASOURCE = "DEFAULT";
```

**示例**：

```java
// 设置默认数据库为 "test"
AbstractSQLConfig.DEFAULT_DATABASE = "test";

// 设置默认模式为 "dbo"
AbstractSQLConfig.DEFAULT_SCHEMA = "dbo";
```

#### 3.4.2 缓存配置

```java
// 启用 SQL 缓存
public static boolean ENABLE_CACHE = true;

// 缓存过期时间（秒）
public static int CACHE_EXPIRE_TIME = 60;

// 最大缓存数量
public static int MAX_CACHE_SIZE = 1000;
```

**示例**：

```java
// 设置缓存过期时间为 300 秒
AbstractSQLConfig.CACHE_EXPIRE_TIME = 300;

// 设置最大缓存数量为 5000
AbstractSQLConfig.MAX_CACHE_SIZE = 5000;
```

## 4. 数据源配置

### 4.1 单数据源配置

#### 4.1.1 使用 DemoSQLExecutor

```java
public class DemoSQLExecutor extends AbstractSQLExecutor {

    @Override
    public Connection getConnection() throws SQLException {
        // 创建数据库连接
        String url = "jdbc:mysql://localhost:3306/test";
        String username = "root";
        String password = "password";
        
        return DriverManager.getConnection(url, username, password);
    }
}
```

#### 4.1.2 使用连接池

```java
public class DemoSQLExecutor extends AbstractSQLExecutor {

    private DataSource dataSource;

    public DemoSQLExecutor() {
        // 初始化连接池
        HikariConfig config = new HikariConfig();
        config.setJdbcUrl("jdbc:mysql://localhost:3306/test");
        config.setUsername("root");
        config.setPassword("password");
        config.setMaximumPoolSize(10);
        
        this.dataSource = new HikariDataSource(config);
    }

    @Override
    public Connection getConnection() throws SQLException {
        return dataSource.getConnection();
    }
}
```

### 4.2 多数据源配置

#### 4.2.1 配置多个数据源

```java
public class DemoSQLExecutor extends AbstractSQLExecutor {

    private Map<String, DataSource> dataSourceMap = new HashMap<>();

    public DemoSQLExecutor() {
        // 初始化主数据源
        HikariConfig masterConfig = new HikariConfig();
        masterConfig.setJdbcUrl("jdbc:mysql://localhost:3306/master");
        masterConfig.setUsername("root");
        masterConfig.setPassword("password");
        dataSourceMap.put("master", new HikariDataSource(masterConfig));

        // 初始化从数据源
        HikariConfig slaveConfig = new HikariConfig();
        slaveConfig.setJdbcUrl("jdbc:mysql://localhost:3306/slave");
        slaveConfig.setUsername("root");
        slaveConfig.setPassword("password");
        dataSourceMap.put("slave", new HikariDataSource(slaveConfig));
    }

    @Override
    public Connection getConnection() throws SQLException {
        String datasource = getConfig().getDatasource();
        DataSource dataSource = dataSourceMap.get(datasource);
        
        if (dataSource == null) {
            throw new SQLException("数据源不存在: " + datasource);
        }
        
        return dataSource.getConnection();
    }
}
```

#### 4.2.2 在请求中指定数据源

```json
{
  "User": {
    "@datasource": "master",
    "id": 1
  }
}
```

## 5. 验证器配置

### 5.1 自定义验证器

```java
public class DemoVerifier extends AbstractVerifier {

    @Override
    public boolean verifyAccess(SQLConfig config) throws Exception {
        // 自定义权限验证逻辑
        String table = config.getTable();
        RequestMethod method = config.getMethod();
        String role = config.getRole();

        // 示例：只有 ADMIN 角色可以删除数据
        if (method == RequestMethod.DELETE && !"ADMIN".equals(role)) {
            throw new IllegalAccessException("只有 ADMIN 角色可以删除数据");
        }

        return super.verifyAccess(config);
    }

    @Override
    public M verifyRequest(RequestMethod method, String name, M target, 
                          M request, int maxUpdateCount, 
                          String database, String schema) {
        // 自定义请求验证逻辑
        
        return super.verifyRequest(method, name, target, request, 
                                 maxUpdateCount, database, schema);
    }
}
```

### 5.2 注册验证器

```java
public class DemoParser extends AbstractParser {

    @Override
    public Verifier createVerifier() {
        return new DemoVerifier();
    }
}
```

## 6. 函数解析器配置

### 6.1 自定义函数解析器

```java
public class DemoFunctionParser extends AbstractFunctionParser {

    @Override
    public Object invoke(String function, M current) throws Exception {
        // 自定义函数调用逻辑
        
        return super.invoke(function, current);
    }
}
```

### 6.2 注册函数解析器

```java
public class DemoParser extends AbstractParser {

    @Override
    public FunctionParser createFunctionParser() {
        return new DemoFunctionParser();
    }
}
```

### 6.3 注册自定义函数

```java
public class DemoFunctionParser extends AbstractFunctionParser {

    static {
        // 注册自定义函数
        FUNCTION_MAP.put("customFunction", new HashMap<String, Object>() {{
            put("language", "java");
            put("version", 1);
            put("tag", "User");
            put("methods", "GET,POST");
            put("returnType", "String");
        }});
    }

    // 自定义函数实现
    public String customFunction(Map<String, Object> request, String arg1, String arg2) {
        return arg1 + " - " + arg2;
    }
}
```

### 6.4 使用自定义函数

```json
{
  "User": {
    "name": "customFunction('hello', 'world')"
  }
}
```

## 7. 脚本执行器配置

### 7.1 注册 JavaScript 执行器

```java
public class DemoFunctionParser extends AbstractFunctionParser {

    static {
        // 注册 JavaScript 执行器
        SCRIPT_EXECUTOR_MAP.put("javascript", new JavaScriptExecutor());
    }
}
```

### 7.2 使用脚本函数

```json
{
  "User": {
    "name": "script:javascript:hello('world')"
  }
}
```

## 8. Spring Boot 集成配置

### 8.1 添加依赖

```xml
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-jdbc</artifactId>
</dependency>
<dependency>
    <groupId>com.github.Tencent</groupId>
    <artifactId>APIJSON</artifactId>
    <version>8.1.0</version>
</dependency>
```

### 8.2 配置数据源

```yaml
spring:
  datasource:
    url: jdbc:mysql://localhost:3306/test
    username: root
    password: password
    driver-class-name: com.mysql.cj.jdbc.Driver
```

### 8.3 创建配置类

```java
@Configuration
public class APIJSONConfig {

    @Bean
    public SQLExecutor sqlExecutor(DataSource dataSource) {
        return new AbstractSQLExecutor() {
            @Override
            public Connection getConnection() throws SQLException {
                return dataSource.getConnection();
            }
        };
    }

    @Bean
    public Verifier verifier() {
        return new DemoVerifier();
    }

    @Bean
    public FunctionParser functionParser() {
        return new DemoFunctionParser();
    }

    @Bean
    public Parser parser(SQLExecutor sqlExecutor, Verifier verifier, 
                       FunctionParser functionParser) {
        return new AbstractParser() {
            @Override
            public SQLExecutor createSQLExecutor() {
                return sqlExecutor;
            }

            @Override
            public Verifier createVerifier() {
                return verifier;
            }

            @Override
            public FunctionParser createFunctionParser() {
                return functionParser;
            }
        };
    }
}
```

### 8.4 创建 Controller

```java
@RestController
@RequestMapping("/api")
public class APIJSONController {

    @Autowired
    private Parser parser;

    @PostMapping
    public String parse(@RequestBody String request) {
        return parser.parse(request);
    }
}
```

## 9. 数据库特定配置

### 9.1 MySQL 配置

```java
// 设置数据库类型为 MySQL
AbstractSQLConfig.DATABASE = "MYSQL";

// MySQL 特定配置
public class MySQLSQLConfig extends AbstractSQLConfig {

    @Override
    public String getQuote() {
        return "`";
    }

    @Override
    public String getLimitString(int count, int page) {
        return " LIMIT " + count + " OFFSET " + page;
    }
}
```

### 9.2 PostgreSQL 配置

```java
// 设置数据库类型为 PostgreSQL
AbstractSQLConfig.DATABASE = "POSTGRESQL";

// PostgreSQL 特定配置
public class PostgreSQLSQLConfig extends AbstractSQLConfig {

    @Override
    public String getQuote() {
        return "\"";
    }

    @Override
    public String getLimitString(int count, int page) {
        return " LIMIT " + count + " OFFSET " + page;
    }
}
```

### 9.3 Oracle 配置

```java
// 设置数据库类型为 Oracle
AbstractSQLConfig.DATABASE = "ORACLE";

// Oracle 特定配置
public class OracleSQLConfig extends AbstractSQLConfig {

    @Override
    public String getQuote() {
        return "\"";
    }

    @Override
    public String getLimitString(int count, int page) {
        return " AND ROWNUM <= " + (page + count);
    }
}
```

## 10. 缓存配置

### 10.1 启用缓存

```java
// 启用 SQL 缓存
AbstractSQLConfig.ENABLE_CACHE = true;

// 设置缓存过期时间
AbstractSQLConfig.CACHE_EXPIRE_TIME = 60;

// 设置最大缓存数量
AbstractSQLConfig.MAX_CACHE_SIZE = 1000;
```

### 10.2 在请求中指定缓存

```json
{
  "User": {
    "@cache": "60",
    "id": 1
  }
}
```

### 10.3 清除缓存

```java
// 清除所有缓存
AbstractSQLExecutor.clearCache();

// 清除指定缓存
AbstractSQLExecutor.removeCache(cacheKey);
```

## 11. 性能优化配置

### 11.1 连接池配置

```java
// 使用 HikariCP 连接池
HikariConfig config = new HikariConfig();
config.setJdbcUrl("jdbc:mysql://localhost:3306/test");
config.setUsername("root");
config.setPassword("password");
config.setMaximumPoolSize(20);
config.setMinimumIdle(5);
config.setConnectionTimeout(30000);
config.setIdleTimeout(600000);
config.setMaxLifetime(1800000);

DataSource dataSource = new HikariDataSource(config);
```

### 11.2 批量操作配置

```java
// 设置最大批量操作数量
AbstractSQLConfig.MAX_UPDATE_COUNT = 100;

// 启用批量操作
AbstractSQLExecutor.ENABLE_BATCH = true;
```

### 11.3 查询优化配置

```java
// 设置最大查询深度
AbstractParser.MAX_QUERY_DEPTH = 5;

// 设置最大 SQL 执行数量
AbstractParser.MAX_SQL_COUNT = 200;

// 启用查询缓存
AbstractSQLConfig.ENABLE_CACHE = true;
```

## 12. 安全配置

### 12.1 SQL 注入防护

APIJSONORM 默认使用 Prepared Statement，可以有效防止 SQL 注入攻击。

```java
// 启用 Prepared Statement
AbstractSQLConfig.PREPARED = true;
```

### 12.2 权限控制

```java
// 启用角色验证
AbstractVerifier.ENABLE_VERIFY_ROLE = true;

// 启用内容验证
AbstractVerifier.ENABLE_VERIFY_CONTENT = true;
```

### 12.3 请求大小限制

```java
// 设置最大请求大小
AbstractParser.MAX_OBJECT_COUNT = 5;
AbstractParser.MAX_ARRAY_COUNT = 5;
```

## 13. 日志配置

### 13.1 启用日志

```java
// 启用请求字符串日志
AbstractParser.IS_PRINT_REQUEST_STRING_LOG = true;

// 启用大数据量日志
AbstractParser.IS_PRINT_BIG_LOG = true;

// 启用请求结束时间日志
AbstractParser.IS_PRINT_REQUEST_ENDTIME_LOG = true;
```

### 13.2 配置日志级别

```xml
<!-- logback.xml -->
<configuration>
    <logger name="apijson" level="DEBUG"/>
</configuration>
```

## 14. 总结

APIJSONORM 提供了丰富的配置选项，主要包括：

1. **基础配置**：Maven/Gradle 依赖
2. **核心配置**：Parser、Verifier、FunctionParser、SQLConfig
3. **数据源配置**：单数据源、多数据源
4. **验证器配置**：自定义验证器
5. **函数解析器配置**：自定义函数、脚本执行器
6. **Spring Boot 集成配置**：数据源、Bean 配置
7. **数据库特定配置**：MySQL、PostgreSQL、Oracle 等
8. **缓存配置**：启用缓存、缓存过期时间
9. **性能优化配置**：连接池、批量操作、查询优化
10. **安全配置**：SQL 注入防护、权限控制
11. **日志配置**：启用日志、日志级别

通过合理配置这些选项，可以根据项目需求优化 APIJSONORM 的性能和安全性。
