# APIJSONORM 最佳实践

## 1. 概述

本文档总结了使用 APIJSONORM 的最佳实践，帮助开发者更好地使用这个框架，提高开发效率和代码质量。

## 2. 项目结构

### 2.1 推荐的项目结构

```
project/
├── src/
│   ├── main/
│   │   ├── java/
│   │   │   ├── config/           # 配置类
│   │   │   │   ├── APIJSONConfig.java
│   │   │   │   ├── DemoSQLExecutor.java
│   │   │   │   └── DemoVerifier.java
│   │   │   ├── controller/       # 控制器
│   │   │   │   └── APIJSONController.java
│   │   │   ├── model/           # 数据模型
│   │   │   │   ├── User.java
│   │   │   │   └── Moment.java
│   │   │   └── function/        # 自定义函数
│   │   │       └── DemoFunctionParser.java
│   │   └── resources/
│   │       └── application.yml
│   └── test/
│       └── java/
│           └── test/            # 测试类
└── pom.xml
```

### 2.2 配置类组织

```java
// config/APIJSONConfig.java
@Configuration
public class APIJSONConfig {

    @Bean
    public SQLExecutor sqlExecutor(DataSource dataSource) {
        return new DemoSQLExecutor(dataSource);
    }

    @Bean
    public Verifier verifier() {
        return new DemoVerifier();
    }

    @Bean
    public FunctionParser functionParser() {
        return new DemoFunctionParser();
    }

    @Bean
    public Parser parser(SQLExecutor sqlExecutor, Verifier verifier, 
                       FunctionParser functionParser) {
        return new DemoParser(sqlExecutor, verifier, functionParser);
    }
}
```

## 3. 数据库设计

### 3.1 表命名规范

- 使用大写字母开头的驼峰命名法
- 使用复数形式表示集合
- 避免使用保留字

**示例**：
```sql
-- 好的命名
CREATE TABLE Users (
    id BIGINT PRIMARY KEY,
    name VARCHAR(100),
    age INT
);

CREATE TABLE UserComments (
    id BIGINT PRIMARY KEY,
    userId BIGINT,
    content TEXT
);

-- 不好的命名
CREATE TABLE user (
    id BIGINT PRIMARY KEY,
    name VARCHAR(100)
);

CREATE TABLE user_comment (
    id BIGINT PRIMARY KEY,
    user_id BIGINT,
    content TEXT
);
```

### 3.2 字段命名规范

- 使用小写字母开头的驼峰命名法
- 使用有意义的字段名
- 避免使用保留字

**示例**：
```sql
-- 好的命名
CREATE TABLE Users (
    id BIGINT PRIMARY KEY,
    userName VARCHAR(100),
    userEmail VARCHAR(100),
    userAge INT,
    createdAt DATETIME,
    updatedAt DATETIME
);

-- 不好的命名
CREATE TABLE Users (
    id BIGINT PRIMARY KEY,
    name VARCHAR(100),
    email VARCHAR(100),
    age INT,
    create_time DATETIME,
    update_time DATETIME
);
```

### 3.3 索引设计

```sql
-- 主键索引
CREATE TABLE Users (
    id BIGINT PRIMARY KEY AUTO_INCREMENT
);

-- 唯一索引
CREATE UNIQUE INDEX idx_user_email ON Users(userEmail);

-- 普通索引
CREATE INDEX idx_user_name ON Users(userName);

-- 复合索引
CREATE INDEX idx_user_name_age ON Users(userName, userAge);
```

## 4. 请求设计

### 4.1 请求结构设计

#### 4.1.1 简单查询

```json
// 好的设计
{
  "User": {
    "id": 1
  }
}

// 不好的设计（过于复杂）
{
  "User": {
    "id": 1,
    "@column": "id,name,age,email,phone,address,createTime,updateTime",
    "@order": "id+",
    "@group": "id",
    "@having": "id>0"
  }
}
```

#### 4.1.2 复杂查询

```json
// 好的设计（结构清晰）
{
  "Moment": {
    "userId": 82001,
    "@column": "id,content,createTime"
  },
  "join": "@/User/id@",
  "User": {
    "@column": "id,name,age"
  }
}

// 不好的设计（结构混乱）
{
  "Moment": {
    "userId": 82001,
    "@column": "id,content,createTime",
    "User": {
      "id": 1,
      "name": "张三"
    }
  }
}
```

### 4.2 字段选择

#### 4.2.1 只查询需要的字段

```json
// 好的设计（只查询需要的字段）
{
  "User": {
    "id": 1,
    "@column": "id,name,age"
  }
}

// 不好的设计（查询所有字段）
{
  "User": {
    "id": 1
  }
}
```

#### 4.2.2 避免查询大字段

```json
// 好的设计（不查询大字段）
{
  "User": {
    "id": 1,
    "@column": "id,name,age"
  }
}

// 不好的设计（查询大字段）
{
  "User": {
    "id": 1,
    "@column": "id,name,age,description,avatar,background"
  }
}
```

### 4.3 分页查询

#### 4.3.1 使用合理的分页大小

```json
// 好的设计（合理的分页大小）
{
  "User[]": {
    "count": 20,
    "page": 0,
    "User": {
      "age>": 18
    }
  }
}

// 不好的设计（分页大小过大）
{
  "User[]": {
    "count": 1000,
    "page": 0,
    "User": {
      "age>": 18
    }
  }
}
```

#### 4.3.2 使用游标分页

```json
// 好的设计（使用游标分页）
{
  "User[]": {
    "count": 20,
    "User": {
      "id>": 1000,
      "@order": "id+"
    }
  }
}

// 不好的设计（使用 OFFSET 分页）
{
  "User[]": {
    "count": 20,
    "page": 1000,
    "User": {
      "@order": "id+"
    }
  }
}
```

### 4.4 条件查询

#### 4.4.1 使用索引字段

```json
// 好的设计（使用索引字段）
{
  "User": {
    "id": 1
  }
}

// 不好的设计（使用非索引字段）
{
  "User": {
    "name": "张三"
  }
}
```

#### 4.4.2 避免全表扫描

```json
// 好的设计（使用索引字段）
{
  "User": {
    "id{}": [1, 2, 3]
  }
}

// 不好的设计（使用 LIKE 查询）
{
  "User": {
    "name~": "张"
  }
}
```

## 5. 性能优化

### 5.1 使用缓存

```json
// 启用缓存
{
  "User": {
    "@cache": "60",
    "id": 1
  }
}
```

### 5.2 批量操作

```json
// 好的设计（批量插入）
{
  "User[]": [
    {
      "name": "张三",
      "age": 25
    },
    {
      "name": "李四",
      "age": 30
    }
  ]
}

// 不好的设计（逐条插入）
{
  "User": {
    "name": "张三",
    "age": 25
  }
}
```

### 5.3 使用 JOIN 代替多次查询

```json
// 好的设计（使用 JOIN）
{
  "Moment": {
    "userId": 82001
  },
  "join": "@/User/id@"
}

// 不好的设计（多次查询）
{
  "Moment": {
    "userId": 82001
  },
  "User": {
    "id": 82001
  }
}
```

## 6. 安全实践

### 6.1 使用 Prepared Statement

APIJSONORM 默认使用 Prepared Statement，可以有效防止 SQL 注入。

### 6.2 启用权限验证

```java
// 启用角色验证
AbstractVerifier.ENABLE_VERIFY_ROLE = true;

// 启用内容验证
AbstractVerifier.ENABLE_VERIFY_CONTENT = true;
```

### 6.3 使用角色控制

```json
// 好的设计（使用角色控制）
{
  "User": {
    "@role": "ADMIN",
    "id": 1
  }
}

// 不好的设计（不使用角色控制）
{
  "User": {
    "id": 1
  }
}
```

### 6.4 限制请求大小

```java
// 设置最大对象数量
AbstractParser.MAX_OBJECT_COUNT = 5;

// 设置最大数组数量
AbstractParser.MAX_ARRAY_COUNT = 5;

// 设置最大查询深度
AbstractParser.MAX_QUERY_DEPTH = 5;
```

## 7. 错误处理

### 7.1 统一错误处理

```java
@RestControllerAdvice
public class GlobalExceptionHandler {

    @ExceptionHandler(Exception.class)
    public String handleException(Exception e) {
        Map<String, Object> result = new HashMap<>();
        result.put("code", 500);
        result.put("msg", e.getMessage());
        return JSON.toJSONString(result);
    }
}
```

### 7.2 错误信息记录

```java
// 记录错误日志
try {
    parser.parse(request);
} catch (Exception e) {
    Log.e(TAG, "请求失败: " + e.getMessage(), e);
    throw e;
}
```

### 7.3 友好的错误提示

```java
// 自定义错误消息
public class DemoVerifier extends AbstractVerifier {

    @Override
    public boolean verifyAccess(SQLConfig config) throws Exception {
        String table = config.getTable();
        String role = config.getRole();

        if ("User".equals(table) && !"ADMIN".equals(role)) {
            throw new IllegalAccessException("只有管理员可以操作用户数据");
        }

        return super.verifyAccess(config);
    }
}
```

## 8. 测试实践

### 8.1 单元测试

```java
@SpringBootTest
public class APIJSONTest {

    @Autowired
    private Parser parser;

    @Test
    public void testGetUser() {
        String request = "{\"User\": {\"id\": 1}}";
        String response = parser.parse(request);
        
        assertNotNull(response);
        assertTrue(response.contains("\"code\":200"));
    }
}
```

### 8.2 集成测试

```java
@SpringBootTest
@AutoConfigureMockMvc
public class APIJSONIntegrationTest {

    @Autowired
    private MockMvc mockMvc;

    @Test
    public void testGetUser() throws Exception {
        String request = "{\"User\": {\"id\": 1}}";
        
        mockMvc.perform(post("/api")
                .contentType(MediaType.APPLICATION_JSON)
                .content(request))
                .andExpect(status().isOk())
                .andExpect(jsonPath("$.code").value(200));
    }
}
```

### 8.3 性能测试

```java
@SpringBootTest
public class APIJSONPerformanceTest {

    @Autowired
    private Parser parser;

    @Test
    public void testPerformance() {
        String request = "{\"User\": {\"id\": 1}}";
        
        long startTime = System.currentTimeMillis();
        for (int i = 0; i < 1000; i++) {
            parser.parse(request);
        }
        long endTime = System.currentTimeMillis();
        
        long duration = endTime - startTime;
        assertTrue(duration < 1000); // 1000次查询应该在1秒内完成
    }
}
```

## 9. 日志记录

### 9.1 启用调试日志

```java
// 启用调试日志
AbstractParser.IS_PRINT_REQUEST_STRING_LOG = true;
AbstractParser.IS_PRINT_BIG_LOG = true;
AbstractParser.IS_PRINT_REQUEST_ENDTIME_LOG = true;
```

### 9.2 记录关键操作

```java
// 记录请求
Log.i(TAG, "请求: " + request);

// 记录响应
Log.i(TAG, "响应: " + response);

// 记录执行时间
Log.i(TAG, "执行时间: " + duration + "ms");
```

### 9.3 使用结构化日志

```java
// 使用结构化日志
Log.i(TAG, JSON.toJSONString(Map.of(
    "action", "getUser",
    "userId", 1,
    "duration", 100,
    "success", true
)));
```

## 10. 部署实践

### 10.1 配置管理

```yaml
# application.yml
apijson:
  cache:
    enabled: true
    expire-time: 60
  query:
    max-count: 100
    max-depth: 5
  log:
    print-request: true
    print-big-log: false
```

### 10.2 环境隔离

```yaml
# application-dev.yml
spring:
  datasource:
    url: jdbc:mysql://localhost:3306/dev

# application-prod.yml
spring:
  datasource:
    url: jdbc:mysql://prod-server:3306/prod
```

### 10.3 监控指标

```java
// 记录监控指标
@Component
public class MetricsCollector {

    private final MeterRegistry meterRegistry;

    public MetricsCollector(MeterRegistry meterRegistry) {
        this.meterRegistry = meterRegistry;
    }

    public void recordRequest(String method, long duration) {
        meterRegistry.counter("apijson.request", "method", method).increment();
        meterRegistry.timer("apijson.duration", "method", method)
                .record(duration, TimeUnit.MILLISECONDS);
    }
}
```

## 11. 代码规范

### 11.1 命名规范

```java
// 好的命名
public class DemoSQLExecutor extends AbstractSQLExecutor { }

public class DemoVerifier extends AbstractVerifier { }

public class DemoFunctionParser extends AbstractFunctionParser { }

// 不好的命名
public class SQLExecutor extends AbstractSQLExecutor { }

public class Verifier extends AbstractVerifier { }

public class FunctionParser extends AbstractFunctionParser { }
```

### 11.2 注释规范

```java
/**
 * Demo SQL 执行器
 * 
 * @author 张三
 * @version 1.0
 */
public class DemoSQLExecutor extends AbstractSQLExecutor {

    /**
     * 获取数据库连接
     * 
     * @return 数据库连接
     * @throws SQLException SQL 异常
     */
    @Override
    public Connection getConnection() throws SQLException {
        // 实现代码
    }
}
```

### 11.3 异常处理

```java
// 好的异常处理
try {
    parser.parse(request);
} catch (NotLoggedInException e) {
    Log.w(TAG, "用户未登录: " + e.getMessage());
    throw new BusinessException("请先登录");
} catch (IllegalAccessException e) {
    Log.w(TAG, "权限不足: " + e.getMessage());
    throw new BusinessException("权限不足");
} catch (Exception e) {
    Log.e(TAG, "系统错误: " + e.getMessage(), e);
    throw new BusinessException("系统错误，请稍后重试");
}

// 不好的异常处理
try {
    parser.parse(request);
} catch (Exception e) {
    e.printStackTrace();
}
```

## 12. 版本管理

### 12.1 使用版本控制

```json
// 使用版本控制
{
  "tag": "getUser",
  "version": 1,
  "User": {
    "id": 1
  }
}
```

### 12.2 向后兼容

```java
// 保持向后兼容
public class DemoVerifier extends AbstractVerifier {

    @Override
    public boolean verifyAccess(SQLConfig config) throws Exception {
        int version = config.getVersion();
        
        // 版本 1 的逻辑
        if (version == 1) {
            return verifyAccessV1(config);
        }
        
        // 版本 2 的逻辑
        if (version == 2) {
            return verifyAccessV2(config);
        }
        
        // 默认逻辑
        return super.verifyAccess(config);
    }
}
```

## 13. 总结

APIJSONORM 的最佳实践主要包括：

1. **项目结构**：合理组织项目结构
2. **数据库设计**：遵循命名规范，合理设计索引
3. **请求设计**：结构清晰，字段合理，分页合理
4. **性能优化**：使用缓存、批量操作、JOIN 查询
5. **安全实践**：使用 Prepared Statement、权限验证、角色控制
6. **错误处理**：统一错误处理、错误信息记录、友好错误提示
7. **测试实践**：单元测试、集成测试、性能测试
8. **日志记录**：启用调试日志、记录关键操作、使用结构化日志
9. **部署实践**：配置管理、环境隔离、监控指标
10. **代码规范**：命名规范、注释规范、异常处理
11. **版本管理**：使用版本控制、保持向后兼容

通过遵循这些最佳实践，可以更好地使用 APIJSONORM，提高开发效率和代码质量。
