# APIJSONORM 高级特性

## 1. 概述

APIJSONORM 提供了许多高级特性，包括 JOIN 查询、子查询、聚合函数、远程函数调用、脚本执行、事务管理等。本文档详细介绍这些高级特性的使用方法。

## 2. JOIN 查询

### 2.1 概述

JOIN 查询允许在一个请求中关联多个表，实现复杂的关联查询。APIJSONORM 支持多种 JOIN 类型。

### 2.2 支持的 JOIN 类型

| 类型 | 符号 | 说明 |
|------|------|------|
| APP JOIN | @ | 应用级 JOIN |
| INNER JOIN | & | 内连接 |
| FULL JOIN | \| | 全连接 |
| LEFT JOIN | < | 左连接 |
| RIGHT JOIN | > | 右连接 |
| OUTER JOIN | ! | 外连接 |
| SIDE JOIN | ^ | 侧连接 |
| ANTI JOIN | ( | 反连接 |
| FOREIGN JOIN | ) | 外键连接 |
| ASOF JOIN | ~ | 时间点连接 |

### 2.3 基本语法

```json
{
  "Table1": {
    "field1": "value1"
  },
  "join": "JOIN_TYPE/Table2/key@"
}
```

### 2.4 使用示例

#### 示例 1：INNER JOIN

```json
// 请求
{
  "Moment": {
    "userId": 82001
  },
  "join": "&/User/id@"
}

// 生成的 SQL
SELECT Moment.*, User.*
FROM Moment
INNER JOIN User ON User.id = Moment.userId
WHERE Moment.userId = 82001

// 响应
{
  "code": 200,
  "msg": "success",
  "Moment": {
    "id": 1,
    "userId": 82001,
    "content": "这是一条动态",
    "User": {
      "id": 82001,
      "name": "张三",
      "age": 25
    }
  }
}
```

#### 示例 2：LEFT JOIN

```json
// 请求
{
  "Moment": {
    "userId": 82001
  },
  "join": "</User/id@"
}

// 生成的 SQL
SELECT Moment.*, User.*
FROM Moment
LEFT JOIN User ON User.id = Moment.userId
WHERE Moment.userId = 82001
```

#### 示例 3：多表 JOIN

```json
// 请求
{
  "Moment": {
    "userId": 82001
  },
  "join": "&/User/id@,&/Comment/toId@"
}

// 生成的 SQL
SELECT Moment.*, User.*, Comment.*
FROM Moment
INNER JOIN User ON User.id = Moment.userId
INNER JOIN Comment ON Comment.toId = Moment.id
WHERE Moment.userId = 82001
```

#### 示例 4：带条件的 JOIN

```json
// 请求
{
  "Moment": {
    "userId": 82001
  },
  "join": {
    "&/User/id@": {
      "age>": 18
    }
  }
}

// 生成的 SQL
SELECT Moment.*, User.*
FROM Moment
INNER JOIN User ON User.id = Moment.userId AND User.age > 18
WHERE Moment.userId = 82001
```

#### 示例 5：指定 JOIN 字段

```json
// 请求
{
  "Moment": {
    "userId": 82001
  },
  "User": {
    "id@": "/Moment/userId"
  },
  "join": "@/User/id@"
}

// 生成的 SQL
SELECT Moment.*, User.*
FROM Moment
INNER JOIN User ON User.id = Moment.userId
WHERE Moment.userId = 82001
```

### 2.5 APP JOIN

APP JOIN 是 APIJSONORM 特有的 JOIN 类型，它在应用层实现 JOIN，而不是在数据库层。

#### 2.5.1 使用场景

- 需要在应用层处理数据
- 数据库不支持某些 JOIN 类型
- 需要更灵活的 JOIN 逻辑

#### 2.5.2 使用示例

```json
// 请求
{
  "Moment": {
    "userId": 82001
  },
  "join": "@/User/id@"
}

// 处理流程
// 1. 查询 Moment 表
// 2. 提取 userId
// 3. 根据 userId 查询 User 表
// 4. 在应用层合并结果

// 响应
{
  "code": 200,
  "msg": "success",
  "Moment": {
    "id": 1,
    "userId": 82001,
    "content": "这是一条动态",
    "User": {
      "id": 82001,
      "name": "张三",
      "age": 25
    }
  }
}
```

## 3. 子查询

### 3.1 概述

子查询允许在一个查询中嵌套另一个查询，实现复杂的查询逻辑。

### 3.2 基本语法

```json
{
  "Table1": {
    "field1": {
      "Table2": {
        "field2": "value"
      }
    }
  }
}
```

### 3.3 使用示例

#### 示例 1：WHERE 子查询

```json
// 请求
{
  "User": {
    "id{}": {
      "Moment": {
        "userId@": "/User/id"
      }
    }
  }
}

// 生成的 SQL
SELECT * FROM User
WHERE id IN (SELECT DISTINCT userId FROM Moment)

// 响应
{
  "code": 200,
  "msg": "success",
  "User": [
    {
      "id": 82001,
      "name": "张三"
    },
    {
      "id": 82002,
      "name": "李四"
    }
  ]
}
```

#### 示例 2：FROM 子查询

```json
// 请求
{
  "User": {
    "id>": {
      "Moment": {
        "@column": "AVG(userId):avgId"
      }
    }
  }
}

// 生成的 SQL
SELECT * FROM User
WHERE id > (SELECT AVG(userId) FROM Moment)
```

#### 示例 3：SELECT 子查询

```json
// 请求
{
  "User": {
    "@column": "id,name,(SELECT COUNT(*) FROM Moment WHERE userId = User.id):momentCount"
  }
}

// 生成的 SQL
SELECT id, name, (SELECT COUNT(*) FROM Moment WHERE userId = User.id) AS momentCount
FROM User
```

### 3.4 子查询范围

#### 3.4.1 ALL 范围

```json
// 请求
{
  "User": {
    "id{}": {
      "range": "ALL",
      "Moment": {
        "userId@": "/User/id"
      }
    }
  }
}
```

#### 3.4.2 ANY 范围

```json
// 请求
{
  "User": {
    "id{}": {
      "range": "ANY",
      "Moment": {
        "userId@": "/User/id"
      }
    }
  }
}
```

## 4. 聚合函数

### 4.1 概述

聚合函数用于对一组值进行计算，返回单个值。

### 4.2 支持的聚合函数

| 函数 | 说明 |
|------|------|
| COUNT | 计数 |
| SUM | 求和 |
| AVG | 平均值 |
| MIN | 最小值 |
| MAX | 最大值 |

### 4.3 使用示例

#### 示例 1：COUNT

```json
// 请求
{
  "User": {
    "@column": "COUNT(*):count"
  }
}

// 生成的 SQL
SELECT COUNT(*) AS count FROM User

// 响应
{
  "code": 200,
  "msg": "success",
  "count": 100
}
```

#### 示例 2：SUM

```json
// 请求
{
  "User": {
    "@column": "SUM(age):totalAge"
  }
}

// 生成的 SQL
SELECT SUM(age) AS totalAge FROM User

// 响应
{
  "code": 200,
  "msg": "success",
  "totalAge": 2500
}
```

#### 示例 3：AVG

```json
// 请求
{
  "User": {
    "@column": "AVG(age):avgAge"
  }
}

// 生成的 SQL
SELECT AVG(age) AS avgAge FROM User

// 响应
{
  "code": 200,
  "msg": "success",
  "avgAge": 25.0
}
```

#### 示例 4：MIN/MAX

```json
// 请求
{
  "User": {
    "@column": "MIN(age):minAge,MAX(age):maxAge"
  }
}

// 生成的 SQL
SELECT MIN(age) AS minAge, MAX(age) AS maxAge FROM User

// 响应
{
  "code": 200,
  "msg": "success",
  "minAge": 18,
  "maxAge": 60
}
```

### 4.4 GROUP BY

#### 4.4.1 基本 GROUP BY

```json
// 请求
{
  "User": {
    "@column": "name,COUNT(*):count",
    "@group": "name"
  }
}

// 生成的 SQL
SELECT name, COUNT(*) AS count
FROM User
GROUP BY name

// 响应
{
  "code": 200,
  "msg": "success",
  "User": [
    {
      "name": "张三",
      "count": 10
    },
    {
      "name": "李四",
      "count": 5
    }
  ]
}
```

#### 4.4.2 多字段 GROUP BY

```json
// 请求
{
  "User": {
    "@column": "name,age,COUNT(*):count",
    "@group": "name,age"
  }
}

// 生成的 SQL
SELECT name, age, COUNT(*) AS count
FROM User
GROUP BY name, age
```

### 4.5 HAVING

#### 4.5.1 基本 HAVING

```json
// 请求
{
  "User": {
    "@column": "name,COUNT(*):count",
    "@group": "name",
    "@having": "count>5"
  }
}

// 生成的 SQL
SELECT name, COUNT(*) AS count
FROM User
GROUP BY name
HAVING count > 5
```

#### 4.5.2 复杂 HAVING

```json
// 请求
{
  "User": {
    "@column": "name,age,COUNT(*):count",
    "@group": "name,age",
    "@having": "count>5 AND age>18"
  }
}

// 生成的 SQL
SELECT name, age, COUNT(*) AS count
FROM User
GROUP BY name, age
HAVING count > 5 AND age > 18
```

## 5. 远程函数调用

### 5.1 概述

远程函数调用允许在请求中调用后端定义的函数，实现复杂的业务逻辑。

### 5.2 基本语法

```json
{
  "Table": {
    "field": "functionName(arg1, arg2, ...)"
  }
}
```

### 5.3 注册函数

```java
public class DemoFunctionParser extends AbstractFunctionParser {

    static {
        // 注册函数
        FUNCTION_MAP.put("customFunction", new HashMap<String, Object>() {{
            put("language", "java");
            put("version", 1);
            put("tag", "User");
            put("methods", "GET,POST");
            put("returnType", "String");
        }});
    }

    // 函数实现
    public String customFunction(Map<String, Object> request, String arg1, String arg2) {
        return arg1 + " - " + arg2;
    }
}
```

### 5.4 使用示例

#### 示例 1：基本函数调用

```json
// 请求
{
  "User": {
    "name": "customFunction('hello', 'world')"
  }
}

// 响应
{
  "code": 200,
  "msg": "success",
  "User": {
    "name": "hello - world"
  }
}
```

#### 示例 2：引用参数

```json
// 请求
{
  "User": {
    "id": 1,
    "name": "customFunction(/User/id, 'world')"
  }
}

// 响应
{
  "code": 200,
  "msg": "success",
  "User": {
    "id": 1,
    "name": "1 - world"
  }
}
```

#### 示例 3：复杂函数

```java
// 函数实现
public List<Map<String, Object>> getUserList(Map<String, Object> request, String minAge, String maxAge) {
    // 实现复杂逻辑
    List<Map<String, Object>> result = new ArrayList<>();
    
    // 查询数据库
    // 处理数据
    // 返回结果
    
    return result;
}
```

```json
// 请求
{
  "User": {
    "@column": "getUserList(18, 60):userList"
  }
}
```

### 5.5 函数参数类型

支持的参数类型：
- Boolean
- Number（Integer, Long, Double, Float）
- String
- Map（JSON 对象）
- List（JSON 数组）

## 6. 脚本执行

### 6.1 概述

脚本执行允许在请求中执行 JavaScript、Lua 等脚本语言，实现动态业务逻辑。

### 6.2 注册脚本执行器

```java
public class DemoFunctionParser extends AbstractFunctionParser {

    static {
        // 注册 JavaScript 执行器
        SCRIPT_EXECUTOR_MAP.put("javascript", new JavaScriptExecutor());
        
        // 注册 Lua 执行器
        SCRIPT_EXECUTOR_MAP.put("lua", new LuaScriptExecutor());
    }
}
```

### 6.3 使用示例

#### 示例 1：JavaScript 脚本

```json
// 请求
{
  "User": {
    "name": "script:javascript:var a = 'hello'; var b = 'world'; a + ' ' + b;"
  }
}

// 响应
{
  "code": 200,
  "msg": "success",
  "User": {
    "name": "hello world"
  }
}
```

#### 示例 2：Lua 脚本

```json
// 请求
{
  "User": {
    "name": "script:lua:local a = 'hello'; local b = 'world'; return a .. ' ' .. b;"
  }
}

// 响应
{
  "code": 200,
  "msg": "success",
  "User": {
    "name": "hello world"
  }
}
```

#### 示例 3：带参数的脚本

```json
// 请求
{
  "User": {
    "id": 1,
    "name": "script:javascript:/User/id + ' - ' + 'world'"
  }
}

// 响应
{
  "code": 200,
  "msg": "success",
  "User": {
    "id": 1,
    "name": "1 - world"
  }
}
```

### 6.4 脚本安全

#### 6.4.1 启用脚本执行

```java
// 启用脚本函数
AbstractFunctionParser.ENABLE_SCRIPT_FUNCTION = true;
```

#### 6.4.2 禁用脚本执行

```java
// 禁用脚本函数
AbstractFunctionParser.ENABLE_SCRIPT_FUNCTION = false;
```

#### 6.4.3 沙箱执行

建议在沙箱环境中执行脚本，避免安全风险。

## 7. 事务管理

### 7.1 概述

事务管理确保多个数据库操作要么全部成功，要么全部失败。

### 7.2 事务隔离级别

```java
// 默认事务隔离级别
public static int DEFAULT_TRANSACTION_ISOLATION = Connection.TRANSACTION_REPEATABLE_READ;

// 支持的事务隔离级别
// Connection.TRANSACTION_NONE
// Connection.TRANSACTION_READ_UNCOMMITTED
// Connection.TRANSACTION_READ_COMMITTED
// Connection.TRANSACTION_REPEATABLE_READ
// Connection.TRANSACTION_SERIALIZABLE
```

### 7.3 使用示例

#### 示例 1：自动事务

```json
// 请求
{
  "User": {
    "@method": "POST",
    "name": "张三",
    "age": 25
  },
  "Moment": {
    "@method": "POST",
    "userId": 1,
    "content": "这是一条动态"
  }
}

// 处理流程
// 1. 开始事务
// 2. 插入 User
// 3. 插入 Moment
// 4. 提交事务

// 如果任一操作失败，则回滚事务
```

#### 示例 2：手动事务

```java
// 开始事务
parser.begin(Connection.TRANSACTION_REPEATABLE_READ);

try {
    // 执行操作
    parser.parse("{\"User\": {\"@method\": \"POST\", \"name\": \"张三\"}}");
    parser.parse("{\"Moment\": {\"@method\": \"POST\", \"userId\": 1, \"content\": \"这是一条动态\"}}");
    
    // 提交事务
    parser.commit();
} catch (Exception e) {
    // 回滚事务
    parser.rollback();
    throw e;
}
```

#### 示例 3：保存点

```java
// 开始事务
parser.begin(Connection.TRANSACTION_REPEATABLE_READ);

try {
    // 执行操作
    parser.parse("{\"User\": {\"@method\": \"POST\", \"name\": \"张三\"}}");
    
    // 创建保存点
    Savepoint savepoint = parser.setSavepoint("savepoint1");
    
    // 执行更多操作
    parser.parse("{\"Moment\": {\"@method\": \"POST\", \"userId\": 1, \"content\": \"这是一条动态\"}}");
    
    // 提交事务
    parser.commit();
} catch (Exception e) {
    // 回滚到保存点
    parser.rollback(savepoint);
    throw e;
}
```

## 8. 缓存机制

### 8.1 概述

缓存机制可以提高查询性能，减少数据库访问。

### 8.2 缓存配置

```java
// 启用缓存
AbstractSQLConfig.ENABLE_CACHE = true;

// 缓存过期时间（秒）
AbstractSQLConfig.CACHE_EXPIRE_TIME = 60;

// 最大缓存数量
AbstractSQLConfig.MAX_CACHE_SIZE = 1000;
```

### 8.3 使用示例

#### 示例 1：启用缓存

```json
// 请求
{
  "User": {
    "@cache": "60",
    "id": 1
  }
}

// 处理流程
// 1. 检查缓存
// 2. 如果缓存存在，返回缓存数据
// 3. 如果缓存不存在，查询数据库
// 4. 将结果存入缓存
// 5. 返回结果
```

#### 示例 2：清除缓存

```java
// 清除所有缓存
AbstractSQLExecutor.clearCache();

// 清除指定缓存
AbstractSQLExecutor.removeCache(cacheKey);
```

#### 示例 3：缓存预热

```java
// 预热缓存
public void warmUpCache() {
    List<Long> userIds = Arrays.asList(1L, 2L, 3L);
    
    for (Long userId : userIds) {
        parser.parse("{\"User\": {\"id\": " + userId + "}}");
    }
}
```

## 9. 批量操作

### 9.1 概述

批量操作可以一次性执行多个操作，提高性能。

### 9.2 使用示例

#### 示例 1：批量插入

```json
// 请求
{
  "User[]": [
    {
      "name": "张三",
      "age": 25
    },
    {
      "name": "李四",
      "age": 30
    },
    {
      "name": "王五",
      "age": 35
    }
  ]
}

// 生成的 SQL
INSERT INTO User (name, age) VALUES ('张三', 25), ('李四', 30), ('王五', 35)

// 响应
{
  "code": 200,
  "msg": "success",
  "count": 3,
  "User[]": [
    {
      "id": 1,
      "name": "张三",
      "age": 25
    },
    {
      "id": 2,
      "name": "李四",
      "age": 30
    },
    {
      "id": 3,
      "name": "王五",
      "age": 35
    }
  ]
}
```

#### 示例 2：批量更新

```json
// 请求
{
  "User[]": [
    {
      "id": 1,
      "age": 26
    },
    {
      "id": 2,
      "age": 31
    }
  ]
}

// 生成的 SQL
UPDATE User SET age = 26 WHERE id = 1
UPDATE User SET age = 31 WHERE id = 2

// 响应
{
  "code": 200,
  "msg": "success",
  "count": 2
}
```

#### 示例 3：批量删除

```json
// 请求
{
  "User": {
    "id{}": [1, 2, 3]
  }
}

// 生成的 SQL
DELETE FROM User WHERE id IN (1, 2, 3)

// 响应
{
  "code": 200,
  "msg": "success",
  "count": 3
}
```

### 9.3 批量操作配置

```java
// 设置最大批量操作数量
AbstractSQLConfig.MAX_UPDATE_COUNT = 100;

// 启用批量操作
AbstractSQLExecutor.ENABLE_BATCH = true;
```

## 10. 引用赋值

### 10.1 概述

引用赋值允许在一个请求中引用另一个字段的值。

### 10.2 基本语法

```json
{
  "Table1": {
    "field1": "value1"
  },
  "Table2": {
    "field2@": "/Table1/field1"
  }
}
```

### 10.3 使用示例

#### 示例 1：引用单个值

```json
// 请求
{
  "User": {
    "id": 1
  },
  "Moment": {
    "userId@": "/User/id"
  }
}

// 处理流程
// 1. 查询 User，获取 id = 1
// 2. 将 id 的值赋给 Moment.userId
// 3. 查询 Moment，WHERE userId = 1
```

#### 示例 2：引用数组值

```json
// 请求
{
  "User[]": {
    "count": 10,
    "User": {
      "age>": 18
    }
  },
  "Moment-userId[]": {
    "Moment": {
      "userId{}@": "/User[]/id"
    }
  }
}

// 处理流程
// 1. 查询 User[]，获取 10 条记录
// 2. 提取所有 id
// 3. 将 id 列表赋给 Moment.userId
// 4. 查询 Moment，WHERE userId IN (id1, id2, ...)
```

#### 示例 3：嵌套引用

```json
// 请求
{
  "User": {
    "id": 1
  },
  "Moment": {
    "userId@": "/User/id",
    "Comment": {
      "toId@": "/Moment/id"
    }
  }
}

// 处理流程
// 1. 查询 User，获取 id = 1
// 2. 将 id 的值赋给 Moment.userId
// 3. 查询 Moment，WHERE userId = 1
// 4. 将 Moment.id 的值赋给 Comment.toId
// 5. 查询 Comment，WHERE toId = Moment.id
```

## 11. 执行计划

### 11.1 概述

执行计划可以查看 SQL 的执行计划，帮助优化查询性能。

### 11.2 使用示例

#### 示例 1：查看执行计划

```json
// 请求
{
  "User": {
    "@explain": true,
    "id": 1
  }
}

// 响应
{
  "code": 200,
  "msg": "success",
  "explain": [
    {
      "id": 1,
      "select_type": "SIMPLE",
      "table": "User",
      "type": "const",
      "possible_keys": "PRIMARY",
      "key": "PRIMARY",
      "key_len": "8",
      "ref": "const",
      "rows": 1,
      "Extra": ""
    }
  ],
  "User": {
    "id": 1,
    "name": "张三"
  }
}
```

## 12. 总结

APIJSONORM 提供了丰富的高级特性：

1. **JOIN 查询**：支持多种 JOIN 类型
2. **子查询**：支持 WHERE、FROM、SELECT 子查询
3. **聚合函数**：支持 COUNT、SUM、AVG、MIN、MAX
4. **远程函数调用**：支持自定义函数
5. **脚本执行**：支持 JavaScript、Lua 等脚本
6. **事务管理**：支持自动和手动事务
7. **缓存机制**：支持查询结果缓存
8. **批量操作**：支持批量插入、更新、删除
9. **引用赋值**：支持字段值引用
10. **执行计划**：支持查看 SQL 执行计划

通过合理使用这些高级特性，可以实现复杂的业务逻辑，提高开发效率和系统性能。
