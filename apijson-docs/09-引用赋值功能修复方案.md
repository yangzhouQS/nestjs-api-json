# 引用赋值功能修复方案

## 问题分析

### 当前问题

在多表关联查询中，引用赋值功能没有正常工作：

**请求示例：**
```json
{
  "receive": {
    "id": 1,
    "@column": "id,order_code,order_date,supplier_name,status,created_at"
  },
  "receive_item": {
    "order_id@": "/receive/id",
    "@column": "id,content"
  }
}
```

**预期行为：**
- 先查询 `receive` 表，获取 `id = 1` 的记录
- 从结果中提取 `id` 的值（例如 `1`）
- 使用提取的值查询 `receive_item` 表：`WHERE order_id = 1`

**实际行为：**
- 引用路径 `"/receive/id"` 被直接作为字符串传递
- SQL 查询变成了：`WHERE order_id = "/receive/id"`（错误）

### 根本原因

1. **解析器阶段**（`core-parser.service.ts`）：
   - 识别了以 `@` 结尾的字段
   - 但只是将引用路径保存到 where 条件中
   - 没有标记这些字段需要后续解析

2. **构建器阶段**（`mysql-builder.service.ts`）：
   - 移除了 `@` 后缀
   - 但将引用路径作为参数直接传递
   - 没有解析引用路径

3. **执行器阶段**（`mysql-executor.service.ts`）：
   - 按顺序执行查询
   - 但没有在查询之间传递和替换引用值

## 解决方案

### 方案概述

实现完整的引用赋值功能，包括：

1. **标记引用字段**：在解析阶段标记需要引用赋值的字段
2. **解析引用路径**：在执行前解析引用路径，提取实际值
3. **替换引用值**：在执行查询时，将引用路径替换为实际值
4. **多表协调**：确保主表先执行，关联表后执行

### 实现步骤

#### 步骤 1：修改接口定义

在 `apijson-request.interface.ts` 中添加引用字段标记：

```typescript
export interface TableQuery {
  name: string;
  operation: TableOperation;
  columns: string[];
  where: any;
  joins: any[];
  group: string[];
  having: any;
  order: string[];
  limit: number;
  offset: number;
  isArray: boolean;
  query?: QueryType;
  cache?: any;
  role?: string;
  database?: string;
  schema?: string;
  explain?: boolean;
  data?: any;
  references?: { [key: string]: string }; // 新增：引用字段映射
}
```

#### 步骤 2：修改解析器

在 `core-parser.service.ts` 中标记引用字段：

```typescript
private parseWhere(tableData: any): { where: any; references: { [key: string]: string } } {
  const where: any = {};
  const references: { [key: string]: string } = {};

  for (const [key, value] of Object.entries(tableData)) {
    // 跳过指令和特殊字段
    if (this.isDirectiveKey(key) || this.isSpecialField(key)) {
      continue;
    }

    // 解析条件
    if (key.endsWith('@')) {
      // 引用赋值，如 order_id@: "/receive/id"
      const fieldName = key.slice(0, -1);
      where[fieldName] = value; // 临时保存引用路径
      references[fieldName] = value; // 记录引用映射
    } else if (key.endsWith('[]')) {
      // IN 条件
      const fieldName = key.slice(0, -2);
      where[fieldName] = { $in: value };
    }
    // ... 其他条件处理
  }

  return { where, references };
}
```

#### 步骤 3：修改构建器

在 `mysql-builder.service.ts` 中处理引用字段：

```typescript
private buildWhereClause(where: any, references?: { [key: string]: string }): { where: string; params: any[] } {
  if (!where || Object.keys(where).length === 0) {
    return { where: '', params: [] };
  }

  const params: any[] = [];
  const conditions = this.buildConditions(where, params, references);
  const whereClause = conditions.length > 0 ? `WHERE ${conditions.join(' AND ')}` : '';

  return { where: whereClause, params };
}

private buildConditions(conditions: any, params: any[], references?: { [key: string]: string }): string[] {
  const result: string[] = [];

  for (const [key, value] of Object.entries(conditions)) {
    // 检查是否为引用字段
    if (references && references[key]) {
      // 引用字段，使用特殊标记
      result.push(`\`${key}\` = ?`);
      params.push({ _reference: references[key] }); // 使用特殊对象标记引用
      continue;
    }

    if (typeof value === 'object' && value !== null && !Array.isArray(value)) {
      // 处理对象条件
      for (const [operator, operand] of Object.entries(value)) {
        const condition = this.buildCondition(key, operator, operand, params);
        if (condition) {
          result.push(condition);
        }
      }
    } else {
      // 处理简单条件
      const condition = this.buildCondition(key, '$eq', value, params);
      if (condition) {
        result.push(condition);
      }
    }
  }

  return result;
}
```

#### 步骤 4：修改执行器

在 `mysql-executor.service.ts` 中实现引用解析和替换：

```typescript
async execute(buildResult: BuildResult): Promise<ExecuteResult> {
  this.logger.log('开始执行 MySQL SQL 查询');

  const data: { [key: string]: any } = {};
  const queryOrder = this.determineQueryOrder(buildResult.queries); // 确定查询顺序

  // 按顺序执行查询
  for (const query of queryOrder) {
    // 解析引用
    const resolvedQuery = this.resolveReferences(query, data);
    const result = await this.executeQuery(resolvedQuery);
    data[query.table] = result;
  }

  const result: ExecuteResult = {
    data,
    directives: buildResult.directives,
    original: buildResult,
  };

  this.logger.log('MySQL SQL 查询执行完成');
  return result;
}

/**
 * 确定查询顺序
 * 主表（无引用）优先，关联表（有引用）后执行
 */
private determineQueryOrder(queries: Query[]): Query[] {
  const mainQueries: Query[] = [];
  const refQueries: Query[] = [];

  for (const query of queries) {
    const hasReferences = this.hasReferences(query);
    if (hasReferences) {
      refQueries.push(query);
    } else {
      mainQueries.push(query);
    }
  }

  return [...mainQueries, ...refQueries];
}

/**
 * 检查查询是否有引用
 */
private hasReferences(query: Query): boolean {
  if (!query.params) {
    return false;
  }

  return query.params.some(param => 
    param && typeof param === 'object' && param._reference
  );
}

/**
 * 解析引用
 * 从已执行的查询结果中提取引用值
 */
private resolveReferences(query: Query, executedData: { [key: string]: any }): Query {
  if (!this.hasReferences(query)) {
    return query;
  }

  const resolvedParams: any[] = [];
  const resolvedQuery = { ...query, params: resolvedParams };

  for (const param of query.params) {
    if (param && typeof param === 'object' && param._reference) {
      // 解析引用路径
      const value = this.extractReferenceValue(param._reference, executedData);
      resolvedParams.push(value);
    } else {
      resolvedParams.push(param);
    }
  }

  return resolvedQuery;
}

/**
 * 从引用路径提取值
 * 支持格式：/table/field, []/table/field
 */
private extractReferenceValue(referencePath: string, executedData: { [key: string]: any }): any {
  // 解析引用路径
  const match = referencePath.match(/^(\[\])?\/(\w+)\/(\w+)$/);
  if (!match) {
    throw new Error(`无效的引用路径: ${referencePath}`);
  }

  const [, isArray, tableName, fieldName] = match;

  // 获取表的数据
  const tableData = executedData[tableName];
  if (!tableData) {
    throw new Error(`引用的表不存在: ${tableName}`);
  }

  // 提取字段值
  if (isArray) {
    // 数组引用：提取所有记录的字段值
    const rows = tableData.data || [];
    return rows.map((row: any) => row[fieldName]);
  } else {
    // 单值引用：提取第一条记录的字段值
    const rows = tableData.data || [];
    if (rows.length === 0) {
      throw new Error(`表 ${tableName} 没有数据`);
    }
    return rows[0][fieldName];
  }
}
```

#### 步骤 5：修改控制器

在 `apijson-request.controller.ts` 中添加日志和错误处理：

```typescript
@Post()
async handleRequest(@Body() request: APIJSONRequest, @Req() req: Request) {
  try {
    this.logger.log(`收到 APIJSON 请求: ${JSON.stringify(request)}`);

    // 解析请求
    const parseResult = await this.parserService.parse(request, req.method);

    // 构建 SQL
    const buildResult = await this.builderService.build(parseResult);

    this.logger.debug(`生成的 SQL: ${JSON.stringify(buildResult.queries.map(q => q.sql))}`);

    // 执行查询
    const executeResult = await this.executorService.execute(buildResult);

    this.logger.log(`查询结果: ${JSON.stringify(executeResult.data)}`);

    return {
      code: 200,
      msg: 'success',
      data: executeResult.data,
    };
  } catch (error) {
    this.logger.error(`请求处理失败: ${error.message}`, error.stack);
    throw new BadRequestException(error.message);
  }
}
```

## 测试用例

### 测试 1：单值引用

```json
{
  "receive": {
    "id": 1,
    "@column": "id,order_code"
  },
  "receive_item": {
    "order_id@": "/receive/id",
    "@column": "id,content"
  }
}
```

**预期 SQL：**
```sql
-- 查询 1
SELECT id, order_code FROM `receive` WHERE id = 1 LIMIT 10;

-- 查询 2（order_id 的值从查询 1 的结果中提取）
SELECT id, content FROM `receive_item` WHERE order_id = 1 LIMIT 10;
```

### 测试 2：数组引用

```json
{
  "receive[]": {
    "count": 5,
    "receive": {
      "@order": "id-"
    }
  },
  "receive_item": {
    "order_id{}@": "[]/receive/id",
    "@column": "id,content"
  }
}
```

**预期 SQL：**
```sql
-- 查询 1
SELECT * FROM `receive` ORDER BY id DESC LIMIT 5;

-- 查询 2（order_id 的值从查询 1 的结果中提取，使用 IN）
SELECT id, content FROM `receive_item` WHERE order_id IN (1, 2, 3, 4, 5) LIMIT 10;
```

### 测试 3：多层引用

```json
{
  "receive": {
    "id": 1
  },
  "receive_item": {
    "order_id@": "/receive/id"
  },
  "product": {
    "id@": "/receive_item/product_id"
  }
}
```

**预期 SQL：**
```sql
-- 查询 1
SELECT * FROM `receive` WHERE id = 1 LIMIT 10;

-- 查询 2
SELECT * FROM `receive_item` WHERE order_id = 1 LIMIT 10;

-- 查询 3（product_id 的值从查询 2 的结果中提取）
SELECT * FROM `product` WHERE id = 100 LIMIT 10;
```

## 注意事项

1. **查询顺序**：必须确保主表先执行，关联表后执行
2. **错误处理**：如果引用的表不存在或没有数据，应该抛出明确的错误
3. **性能优化**：对于数组引用，使用 IN 查询而不是多次查询
4. **日志记录**：记录引用解析过程，便于调试
5. **向后兼容**：确保不影响现有的非引用查询

## 总结

通过以上修复方案，可以实现完整的引用赋值功能，支持：

- ✅ 单值引用：`"order_id@": "/receive/id"`
- ✅ 数组引用：`"order_id{}@": "[]/receive/id"`
- ✅ 多层引用：支持多层级的引用关系
- ✅ 自动解析：自动从已执行的查询结果中提取值
- ✅ 错误处理：明确的错误提示

这将使多表关联查询功能更加完善和易用。
