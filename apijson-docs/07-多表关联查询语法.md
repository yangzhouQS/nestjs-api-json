# APIJSON 多表关联查询语法使用文档

## 1. 概述

APIJSON 提供了强大而灵活的多表关联查询功能，支持多种 JOIN 类型和复杂的关联查询场景。通过 JSON 格式的请求，可以轻松实现一对一、一对多、多对多等各种关联查询，无需编写复杂的 SQL 语句。

## 2. 核心概念

### 2.1 引用赋值

引用赋值是 APIJSON 多表关联查询的核心机制，通过 `key@` 语法实现表之间的关联。

**基本语法：**
```json
"key@": "引用路径"
```

**引用路径格式：**
- **完整路径**：从最外层开始的路径，如 `"id@":"/Moment/userId"`
- **相对路径**：从当前容器父层开始的路径，如 `"id@":"/Moment/userId"`（省略第一个 `/`）

### 2.2 JOIN 类型

APIJSON 支持多种 JOIN 类型，每种类型对应不同的关联方式：

| 类型 | 符号 | 说明 | 对应 SQL |
|------|------|------|----------|
| APP JOIN | `@` | 应用层关联（推荐） | 多次查询 + 应用层合并 |
| LEFT JOIN | `<` | 左连接 | LEFT JOIN |
| RIGHT JOIN | `>` | 右连接 | RIGHT JOIN |
| INNER JOIN | `&` | 内连接 | INNER JOIN |
| FULL JOIN | `\|` | 全连接 | FULL JOIN |
| OUTER JOIN | `!` | 外连接 | LEFT OUTER JOIN |
| CROSS JOIN | `*` | 交叉连接 | CROSS JOIN |
| SIDE JOIN | `^` | 侧连接 | LEFT JOIN |
| ANTI JOIN | `(` | 反连接 | LEFT JOIN + NOT |
| FOREIGN JOIN | `)` | 外键连接 | INNER JOIN |

## 3. 基础关联查询

### 3.1 一对一关联

查询一个 Moment 及其对应的 User 信息。

**请求示例：**
```json
{
  "Moment": {
    "id": 12
  },
  "User": {
    "id@": "/Moment/userId"
  }
}
```

**生成的 SQL：**
```sql
SELECT * FROM Moment WHERE id = 12 LIMIT 1;
SELECT * FROM User WHERE id = (SELECT userId FROM Moment WHERE id = 12 LIMIT 1);
```

**响应示例：**
```json
{
  "code": 200,
  "msg": "success",
  "Moment": {
    "id": 12,
    "userId": 70793,
    "content": "这是一条动态"
  },
  "User": {
    "id": 70793,
    "name": "Strong",
    "sex": 0
  }
}
```

### 3.2 一对多关联

查询一个 User 及其发布的所有 Moment。

**请求示例：**
```json
{
  "User": {
    "id": 82001
  },
  "Moment[]": {
    "count": 10,
    "Moment": {
      "userId@": "/User/id"
    }
  }
}
```

**生成的 SQL：**
```sql
SELECT * FROM User WHERE id = 82001 LIMIT 1;
SELECT * FROM Moment WHERE userId = 82001 LIMIT 10;
```

### 3.3 多对一关联

查询多个 Moment 及其对应的 User。

**请求示例：**
```json
{
  "Moment[]": {
    "count": 5,
    "Moment": {}
  },
  "User": {
    "id@": "[]/Moment/userId"
  }
}
```

**生成的 SQL：**
```sql
SELECT * FROM Moment LIMIT 5;
SELECT * FROM User WHERE id IN (SELECT userId FROM Moment LIMIT 5);
```

## 4. 复杂关联查询

### 4.1 多层嵌套关联

查询 Moment、对应的 User、以及 User 的 Comment。

**请求示例：**
```json
{
  "Moment": {
    "id": 15
  },
  "User": {
    "id@": "/Moment/userId"
  },
  "Comment[]": {
    "count": 3,
    "Comment": {
      "userId@": "/User/id"
    }
  }
}
```

### 4.2 数组内嵌套关联

查询 Moment 列表，每个 Moment 包含对应的 User 和 Comment 列表。

**请求示例：**
```json
{
  "[]": {
    "count": 2,
    "Moment": {
      "content$": "%a%"
    },
    "User": {
      "id@": "/Moment/userId",
      "@column": "id,name,head"
    },
    "Comment[]": {
      "count": 2,
      "Comment": {
        "momentId@": "[]/Moment/id"
      }
    }
  }
}
```

**生成的 SQL：**
```sql
SELECT * FROM Moment WHERE content LIKE '%a%' LIMIT 2;
SELECT id, name, head FROM User WHERE id IN (SELECT userId FROM Moment WHERE content LIKE '%a%' LIMIT 2);
SELECT * FROM Comment WHERE momentId IN (SELECT id FROM Moment WHERE content LIKE '%a%' LIMIT 2) LIMIT 2;
```

**响应示例：**
```json
{
  "code": 200,
  "msg": "success",
  "[]": [
    {
      "Moment": {
        "id": 15,
        "userId": 70793,
        "content": "APIJSON is a JSON Transmission Protocol…"
      },
      "User": {
        "id": 70793,
        "name": "Strong",
        "head": "http://static.oschina.net/uploads/user/585/1170143_50.jpg"
      },
      "Comment[]": [
        {
          "id": 176,
          "momentId": 15,
          "content": "thank you"
        },
        {
          "id": 1490863469638,
          "momentId": 15,
          "content": "Just do it"
        }
      ]
    }
  ]
}
```

### 4.3 多表同时关联

同时查询 Moment、User 和 Comment 三张表。

**请求示例：**
```json
{
  "Moment": {
    "id": 15
  },
  "User": {
    "id@": "/Moment/userId"
  },
  "Comment": {
    "id": 176
  }
}
```

## 5. JOIN 查询

### 5.1 使用 join 关键字

在数组对象中使用 `join` 关键字实现数据库层面的 JOIN。

**基本语法：**
```json
{
  "[]": {
    "join": "JOIN_TYPE/Table/key@",
    "MainTable": {},
    "JoinTable": {
      "key@": "/MainTable/refKey"
    }
  }
}
```

### 5.2 INNER JOIN 示例

查询 Moment 和对应的 User，使用内连接。

**请求示例：**
```json
{
  "Moment": {
    "userId": 82001
  },
  "join": "&/User/id@"
}
```

**生成的 SQL：**
```sql
SELECT Moment.*, User.*
FROM Moment
INNER JOIN User ON User.id = Moment.userId
WHERE Moment.userId = 82001
```

### 5.3 LEFT JOIN 示例

查询 Moment 和对应的 User，使用左连接。

**请求示例：**
```json
{
  "Moment": {
    "userId": 82001
  },
  "join": "</User/id@"
}
```

**生成的 SQL：**
```sql
SELECT Moment.*, User.*
FROM Moment
LEFT JOIN User ON User.id = Moment.userId
WHERE Moment.userId = 82001
```

### 5.4 多表 JOIN

查询 Moment、User 和 Comment，使用多个 JOIN。

**请求示例：**
```json
{
  "Moment": {
    "userId": 82001
  },
  "join": "&/User/id@,&/Comment/toId@"
}
```

**生成的 SQL：**
```sql
SELECT Moment.*, User.*, Comment.*
FROM Moment
INNER JOIN User ON User.id = Moment.userId
INNER JOIN Comment ON Comment.toId = Moment.id
WHERE Moment.userId = 82001
```

### 5.5 带 ON 条件的 JOIN

在 JOIN 时添加额外的 ON 条件。

**请求示例：**
```json
{
  "Moment": {
    "userId": 82001
  },
  "join": {
    "&/User/id@": {
      "age>": 18
    }
  }
}
```

**生成的 SQL：**
```sql
SELECT Moment.*, User.*
FROM Moment
INNER JOIN User ON User.id = Moment.userId AND User.age > 18
WHERE Moment.userId = 82001
```

### 5.6 复杂 JOIN 配置

使用对象格式配置 JOIN，支持更多选项。

**请求示例：**
```json
{
  "[]": {
    "join": {
      "&/User/id@": {
        "name~": "Tom",
        "@combine": "name~",
        "@column": "id,name,age"
      }
    },
    "Moment": {},
    "User": {
      "id@": "/Moment/userId"
    }
  }
}
```

## 6. APP JOIN（应用层关联）

### 6.1 APP JOIN 特点

APP JOIN 是 APIJSON 推荐的关联方式，具有以下特点：

- **性能优化**：自动将多次查询合并为 IN 查询
- **灵活性**：支持复杂的业务逻辑处理
- **兼容性**：不依赖数据库的 JOIN 支持

### 6.2 APP JOIN 示例

**请求示例：**
```json
{
  "Moment": {
    "userId": 82001
  },
  "join": "@/User/id@"
}
```

**处理流程：**
1. 查询 Moment 表，获取所有 userId
2. 将 userId 列表合并为数组
3. 使用 `WHERE userId IN (...)` 查询 User 表
4. 在应用层合并结果

**生成的 SQL：**
```sql
-- 第一次查询
SELECT * FROM Moment WHERE userId = 82001;

-- 第二次查询（优化后）
SELECT * FROM User WHERE id IN (82001, 82002, 82003);
```

### 6.3 APP JOIN vs SQL JOIN

| 特性 | APP JOIN | SQL JOIN |
|------|----------|----------|
| 执行位置 | 应用层 | 数据库层 |
| 查询次数 | 2 次 | 1 次 |
| 性能 | 适合小数据量 | 适合大数据量 |
| 灵活性 | 高 | 中 |
| 兼容性 | 所有数据库 | 依赖数据库支持 |

## 7. 子查询关联

### 7.1 WHERE 子查询

使用子查询作为 WHERE 条件。

**请求示例：**
```json
{
  "User": {
    "id{}": {
      "Moment": {
        "userId@": "/User/id"
      }
    }
  }
}
```

**生成的 SQL：**
```sql
SELECT * FROM User
WHERE id IN (SELECT DISTINCT userId FROM Moment)
```

### 7.2 比较子查询

使用子查询进行比较。

**请求示例：**
```json
{
  "User": {
    "id>": {
      "Moment": {
        "@column": "AVG(userId):avgId"
      }
    }
  }
}
```

**生成的 SQL：**
```sql
SELECT * FROM User
WHERE id > (SELECT AVG(userId) FROM Moment)
```

### 7.3 EXISTS 子查询

使用 EXISTS 判断是否存在。

**请求示例：**
```json
{
  "User": {
    "id}{@": {
      "from": "Comment",
      "Comment": {
        "momentId": 15
      }
    }
  }
}
```

**生成的 SQL：**
```sql
SELECT * FROM User
WHERE EXISTS (SELECT * FROM Comment WHERE momentId = 15)
```

## 8. 高级关联技巧

### 8.1 指定查询字段

在关联查询中指定需要返回的字段。

**请求示例：**
```json
{
  "Moment": {
    "id": 15
  },
  "User": {
    "id@": "/Moment/userId",
    "@column": "id,name,head"
  }
}
```

### 8.2 添加查询条件

在关联查询中添加过滤条件。

**请求示例：**
```json
{
  "Moment": {
    "id": 15
  },
  "User": {
    "id@": "/Moment/userId",
    "sex": 0,
    "age>": 18
  }
}
```

### 8.3 排序和分页

在关联查询中使用排序和分页。

**请求示例：**
```json
{
  "Moment[]": {
    "count": 10,
    "page": 0,
    "Moment": {
      "@order": "date-"
    }
  },
  "User": {
    "id@": "[]/Moment/userId"
  }
}
```

### 8.4 聚合函数关联

在关联查询中使用聚合函数。

**请求示例：**
```json
{
  "User": {
    "id": 82001
  },
  "Moment[]": {
    "count": 0,
    "Moment": {
      "userId@": "/User/id",
      "@column": "COUNT(*):total"
    }
  }
}
```

### 8.5 分组关联

在关联查询中使用分组。

**请求示例：**
```json
{
  "User": {
    "id": 82001
  },
  "Moment[]": {
    "Moment": {
      "userId@": "/User/id",
      "@column": "userId,COUNT(*):count",
      "@group": "userId"
    }
  }
}
```

## 9. 性能优化建议

### 9.1 使用 APP JOIN

对于小数据量的关联查询，优先使用 APP JOIN。

**推荐：**
```json
{
  "Moment": {},
  "join": "@/User/id@"
}
```

### 9.2 合理使用 JOIN

对于大数据量的关联查询，使用 SQL JOIN。

**推荐：**
```json
{
  "Moment": {},
  "join": "&/User/id@"
}
```

### 9.3 避免过深嵌套

避免超过 3 层的嵌套关联，考虑拆分为多个请求。

**不推荐：**
```json
{
  "Moment": {},
  "User": {
    "id@": "/Moment/userId",
    "Comment[]": {
      "Comment": {
        "User": {
          "id@": "/Comment/userId",
          "Moment": {}
        }
      }
    }
  }
}
```

**推荐：**
```json
// 第一次请求
{
  "Moment": {},
  "User": {
    "id@": "/Moment/userId"
  }
}

// 第二次请求
{
  "Comment[]": {
    "Comment": {
      "userId@": "/User/id"
    }
  }
}
```

### 9.4 使用索引

确保关联字段上有索引，提高查询性能。

**SQL 示例：**
```sql
CREATE INDEX idx_user_id ON Moment(userId);
CREATE INDEX idx_moment_id ON Comment(momentId);
```

### 9.5 限制返回字段

只查询需要的字段，减少数据传输量。

**推荐：**
```json
{
  "Moment": {
    "@column": "id,userId,content"
  },
  "User": {
    "id@": "/Moment/userId",
    "@column": "id,name"
  }
}
```

## 10. 常见场景示例

### 10.1 朋友圈场景

查询朋友圈动态列表，包含发布者信息和评论列表。

**请求示例：**
```json
{
  "[]": {
    "page": 0,
    "count": 10,
    "Moment": {
      "@order": "date-"
    },
    "User": {
      "id@": "/Moment/userId",
      "@column": "id,name,head,sex"
    },
    "Comment[]": {
      "count": 3,
      "Comment": {
        "momentId@": "[]/Moment/id",
        "@order": "date+"
      }
    }
  }
}
```

### 10.2 订单场景

查询订单列表，包含商品信息和用户信息。

**请求示例：**
```json
{
  "Order[]": {
    "page": 0,
    "count": 10,
    "Order": {
      "userId": 82001
    }
  },
  "User": {
    "id@": "[]/Order/userId",
    "@column": "id,name,phone"
  },
  "Product[]": {
    "Product": {
      "id{}@": "[]/Order/productId"
    }
  }
}
```

### 10.3 权限场景

查询用户有权限访问的资源列表。

**请求示例：**
```json
{
  "User": {
    "id": 82001
  },
  "Role[]": {
    "Role": {
      "userId@": "/User/id"
    }
  },
  "Resource[]": {
    "Resource": {
      "roleId{}@": "[]/Role/id"
    }
  }
}
```

### 10.4 统计场景

查询用户的统计数据。

**请求示例：**
```json
{
  "User": {
    "id": 82001
  },
  "Moment-count": {
    "Moment": {
      "userId@": "/User/id",
      "@column": "COUNT(*):count"
    }
  },
  "Comment-count": {
    "Comment": {
      "userId@": "/User/id",
      "@column": "COUNT(*):count"
    }
  }
}
```

## 11. 错误处理

### 11.1 引用路径错误

**错误示例：**
```json
{
  "User": {
    "id@": "/Moment/userId"  // Moment 不存在
  }
}
```

**错误信息：**
```json
{
  "code": 404,
  "msg": "引用路径 /Moment/userId 不存在"
}
```

### 11.2 字段类型不匹配

**错误示例：**
```json
{
  "Moment": {
    "userId": "abc"  // userId 应该是数字
  },
  "User": {
    "id@": "/Moment/userId"
  }
}
```

### 11.3 循环引用

**错误示例：**
```json
{
  "User": {
    "id@": "/Moment/userId"
  },
  "Moment": {
    "userId@": "/User/id"
  }
}
```

## 12. 最佳实践

### 12.1 命名规范

- 表名使用大驼峰：`User`, `Moment`, `Comment`
- 字段名使用小驼峰：`userId`, `momentId`, `createTime`
- 数组使用 `[]` 后缀：`User[]`, `Moment[]`

### 12.2 请求结构

- 将主表放在前面
- 关联表使用引用赋值
- 数组查询使用 `[]` 包装

### 12.3 性能考虑

- 优先使用 APP JOIN
- 合理使用 JOIN
- 限制返回字段
- 添加适当的索引

### 12.4 安全考虑

- 验证用户权限
- 限制查询数量
- 过滤敏感字段
- 使用参数化查询

## 13. 总结

APIJSON 的多表关联查询功能提供了强大而灵活的查询能力：

1. **引用赋值**：通过 `key@` 语法实现表关联
2. **多种 JOIN 类型**：支持 10 种不同的 JOIN 方式
3. **APP JOIN**：应用层关联，性能优化
4. **子查询**：支持复杂的子查询逻辑
5. **嵌套关联**：支持多层嵌套关联
6. **性能优化**：提供多种优化手段

通过合理使用这些功能，可以轻松实现各种复杂的关联查询场景，无需编写复杂的 SQL 语句。
